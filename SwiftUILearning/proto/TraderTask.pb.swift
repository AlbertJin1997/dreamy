// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TraderTask.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Author      : meiyu024717@gtjas.com
// Version     : TT_V1.1
// Update      : 2024/03/13
// Discription : 期权自对冲撤销 新增入参合约代码

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///心跳包
struct Com_Gtjaqh_Trader_Task_SystemHeartbeatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///empty
struct Com_Gtjaqh_Trader_Task_SystemHeartbeatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///缓存确认回报 - 提醒客户端缓存更新，需要客户端主动发起查询 (901)
struct Com_Gtjaqh_Trader_Task_SystemQueryCacheConfirmationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码 - 此消息不会返回错误
  var errorID: String = String()

  ///错误信息 - 此消息不会返回错误
  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交易登录请求 (28017->1001)
struct Com_Gtjaqh_Trader_Task_UserLoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var userID: String = String()

  ///资金密码
  var password: String = String()

  ///App代码
  var appID: String = String()

  ///认证码
  var authCode: String = String()

  ///穿透式信息采集字段
  var clientSysInfo: String = String()

  ///唯一标识码
  var mobileUuid: String = String()

  ///是否启用token获取 (1=是;0=否)
  var tradeTokenRequired: String = String()

  ///系统版本号
  var xOsVersion: String = String()

  ///手机型号
  var xModel: String = String()

  ///公网ip (由网关填充)
  var ip: String = String()

  ///公网port (由网关填充)
  var port: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交易登录结果
struct Com_Gtjaqh_Trader_Task_UserLoginResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///警示信息
  var alertInfo: String = String()

  ///修改密码标记 (1=需要修改密码;0=不需要修改密码)
  var initPasswordFlag: String = String()

  ///当前交易日期
  var tradingDay: String = String()

  ///是否已确认过结算单 (1=是;0=否)
  var settlementInfoConfirmed: String = String()

  ///资金账号
  var userID: String = String()

  ///交易token
  var tradeToken: String = String()

  ///查询token
  var queryToken: String = String()

  ///经纪公司代码
  var brokerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///重连请求 (1002)
struct Com_Gtjaqh_Trader_Task_UserReconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易token
  var tradeToken: String = String()

  ///查询token - query_token 为实际校验token，为兼容老版本，保留 trade_token
  var queryToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserReconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码 (0=正常登录;1=token失效)
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///资金账号
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///登出 (1003)
struct Com_Gtjaqh_Trader_Task_UserLogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserLogoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码 (0=成功;此接口只要收到回调即可认为成功登出)
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///获取交易结算单 (1521->1005)
struct Com_Gtjaqh_Trader_Task_UserSettlementInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  ///交易日 (查询某天yyyymmdd;某月yyyymm;建议填空,默认最新)
  var tradingDay: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserSettlementInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///结算单字符串消息正文
  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交易结算单确认 (1006)
struct Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///确认日期 yyyymmdd
  var confirmDate: String = String()

  ///确认时间
  var confirmTime: String = String()

  ///结算编号
  var settlementID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///用户账户密码更新 (1077)
struct Com_Gtjaqh_Trader_Task_UserPasswordUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户代码
  var userID: String = String()

  ///旧口令
  var oldPassword: String = String()

  ///新口令
  var newPassword: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserPasswordUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///资金账户密码更新 (1078)
struct Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者账号
  var accountID: String = String()

  ///旧口令
  var oldPassword: String = String()

  ///新口令
  var newPassword: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询此会话已成功登录挂接的用户（主要面向交易服务） (1100)
struct Com_Gtjaqh_Trader_Task_QueryUsersOnlineRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryUsersOnlineResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各用户
  var users: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询持仓 (1503->2001)
struct Com_Gtjaqh_Trader_Task_QueryPositionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  ///查询数量 (选填项,当前建议前端不填/填0，后台不作限制)
  var requestNum: Int32 = 0

  ///合约代码 (填空默认全量查询)
  var instrumentID: String = String()

  ///只查询期权
  var isOptionsOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryPositionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔持仓明细 - is_options_only 会影响此字段返回
  var positionFields: [Com_Gtjaqh_Trader_Task_PositionField] = []

  ///各笔持仓明细 - 协议兼容恒生中继字段,返回全量期权持仓(与is_options_only无关)
  var optionPositionFields: [Com_Gtjaqh_Trader_Task_PositionField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询委托 (1504->2033)
struct Com_Gtjaqh_Trader_Task_QueryOrderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  ///查询数量 (选填项,当前建议前端不填/填0，后台不作限制)
  var requestNum: Int32 = 0

  ///合约代码 (填空默认全量查询)
  var instrumentID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryOrderResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔委托信息
  var orderFields: [Com_Gtjaqh_Trader_Task_OrderField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询成交 (1506->2034)
struct Com_Gtjaqh_Trader_Task_QueryTradeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  ///查询数量 (选填项,当前建议前端不填/填0，后台不作限制)
  var requestNum: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryTradeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔成交信息
  var tradeFields: [Com_Gtjaqh_Trader_Task_TradeField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询执行宣告 - 查询期权行权委托 (1602->2133)
struct Com_Gtjaqh_Trader_Task_QueryExecOrderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码 (填空默认全量查询)
  var instrumentID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///报单编号 (填空默认全量查询)
  var execOrderSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryExecOrderResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔行权结果信息
  var execOrderFields: [Com_Gtjaqh_Trader_Task_ExecOrderField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询期权自对冲委托
struct Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码 (填空默认全量查询)
  var instrumentID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///报单编号 (填空默认全量查询)
  var optionSelfCloseSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔期权自对冲委托结果信息
  var optionSelfCloseFields: [Com_Gtjaqh_Trader_Task_OptionSelfCloseField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询交易编码 (1500->3001)
struct Com_Gtjaqh_Trader_Task_QueryTradingCodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryTradingCodeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各交易所交易编码
  var tradingCodes: [Com_Gtjaqh_Trader_Task_TradingCode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询资金账户 (1508->3008)
struct Com_Gtjaqh_Trader_Task_QueryTradingAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///资金账号
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryTradingAccountResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String {
    get {return _storage._errorID}
    set {_uniqueStorage()._errorID = newValue}
  }

  ///错误信息
  var errorMsg: String {
    get {return _storage._errorMsg}
    set {_uniqueStorage()._errorMsg = newValue}
  }

  ///可用资金
  var available: String {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  ///可取资金
  var withdrawQuota: String {
    get {return _storage._withdrawQuota}
    set {_uniqueStorage()._withdrawQuota = newValue}
  }

  ///冻结权利金 (原名冻结资金)
  var frozenCash: String {
    get {return _storage._frozenCash}
    set {_uniqueStorage()._frozenCash = newValue}
  }

  ///盯市盈亏 - 持仓盈亏
  var positionProfit: String {
    get {return _storage._positionProfit}
    set {_uniqueStorage()._positionProfit = newValue}
  }

  ///盯市浮盈率 (盯市浮盈率=盯市盈亏/客户保证金)
  var positionProfitRate: String {
    get {return _storage._positionProfitRate}
    set {_uniqueStorage()._positionProfitRate = newValue}
  }

  ///平仓盈亏
  var closeProfit: String {
    get {return _storage._closeProfit}
    set {_uniqueStorage()._closeProfit = newValue}
  }

  ///平仓盈亏率 (平仓盈亏率=平仓盈亏/期初权益)
  var closeProfitRate: String {
    get {return _storage._closeProfitRate}
    set {_uniqueStorage()._closeProfitRate = newValue}
  }

  ///当日开仓预冻结金额 - 冻结的保证金
  var frozenMargin: String {
    get {return _storage._frozenMargin}
    set {_uniqueStorage()._frozenMargin = newValue}
  }

  ///客户保证金 - 当前保证金总额
  var currMargin: String {
    get {return _storage._currMargin}
    set {_uniqueStorage()._currMargin = newValue}
  }

  ///客户风险率 (curr_margin*100/balance)
  var riskRate: String {
    get {return _storage._riskRate}
    set {_uniqueStorage()._riskRate = newValue}
  }

  ///期初客户权益 - 昨权益
  var preBalance: String {
    get {return _storage._preBalance}
    set {_uniqueStorage()._preBalance = newValue}
  }

  ///客户市值权益 - 期货结算准备金
  var balance: String {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  ///货币质入金额
  var fundMortgageIn: String {
    get {return _storage._fundMortgageIn}
    set {_uniqueStorage()._fundMortgageIn = newValue}
  }

  ///货币质出金额
  var fundMortgageOut: String {
    get {return _storage._fundMortgageOut}
    set {_uniqueStorage()._fundMortgageOut = newValue}
  }

  ///成交手续费金额 - 手续费
  var commission: String {
    get {return _storage._commission}
    set {_uniqueStorage()._commission = newValue}
  }

  ///冻结手续费
  var frozenCommission: String {
    get {return _storage._frozenCommission}
    set {_uniqueStorage()._frozenCommission = newValue}
  }

  ///上次质押金额
  var preMortgage: String {
    get {return _storage._preMortgage}
    set {_uniqueStorage()._preMortgage = newValue}
  }

  ///质押金额
  var mortgage: String {
    get {return _storage._mortgage}
    set {_uniqueStorage()._mortgage = newValue}
  }

  ///货币质押余额
  var fundMortgageAvailable: String {
    get {return _storage._fundMortgageAvailable}
    set {_uniqueStorage()._fundMortgageAvailable = newValue}
  }

  ///可质押货币金额
  var mortgageableFund: String {
    get {return _storage._mortgageableFund}
    set {_uniqueStorage()._mortgageableFund = newValue}
  }

  ///币种代码 (CNY=人民币;USD=美元;HKD=港币)
  var currencyID: String {
    get {return _storage._currencyID}
    set {_uniqueStorage()._currencyID = newValue}
  }

  ///更新时间 "MM/DD hh:mm"
  var updateTime: String {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  ///入金金额
  var deposit: String {
    get {return _storage._deposit}
    set {_uniqueStorage()._deposit = newValue}
  }

  ///出金金额
  var withdraw: String {
    get {return _storage._withdraw}
    set {_uniqueStorage()._withdraw = newValue}
  }

  ///投资者交割保证金
  var deliveryMargin: String {
    get {return _storage._deliveryMargin}
    set {_uniqueStorage()._deliveryMargin = newValue}
  }

  ///币种代码名称
  var currencyIDName: String {
    get {return _storage._currencyIDName}
    set {_uniqueStorage()._currencyIDName = newValue}
  }

  ///总冻结金额 (冻结权利金+冻结保证金+冻结手续费)
  var totalFrozenMoney: String {
    get {return _storage._totalFrozenMoney}
    set {_uniqueStorage()._totalFrozenMoney = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///保证金查询 (1544->3044)
struct Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///投机套保标志
  var hedgeFlag: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///保证金率
  var marginRatioByMoney: String = String()

  ///保证金费
  var marginRatioByVolume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询期权交易成本 (3050)
///1.此接口只是估计计算，因为其使用的公式（保证金=max(权利金+FixedMargin,MiniMargin)）中的
///权利金部分在计算时使用的期权价格是InputPrice
///2.资金查询里的期权保证金计算公式中的期权价格是使用max算法（max(昨结算，最新价)）得到的
struct Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///期权合约报价
  var inputPrice: String = String()

  ///标的价格 - 默认填0,以昨结算价计算
  var underlyingPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///期权合约保证金不变部分
  var fixedMargin: String = String()

  ///期权合约最小保证金
  var miniMargin: String = String()

  ///期权合约权利金
  var royalty: String = String()

  ///交易所期权合约保证金不变部分
  var exchFixedMargin: String = String()

  ///交易所期权合约最小保证金
  var exchMiniMargin: String = String()

  ///合约代码
  var instrumentID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询合约手续费 (3077)
struct Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码
  var instrumentID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///开仓手续费率
  var openRatioByMoney: String = String()

  ///开仓手续费
  var openRatioByVolume: String = String()

  ///平仓手续费率
  var closeRatioByMoney: String = String()

  ///平仓手续费
  var closeRatioByVolume: String = String()

  ///平今手续费率
  var closeTodayRatioByMoney: String = String()

  ///平今手续费
  var closeTodayRatioByVolume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询期权合约手续费 (3078)
struct Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  ///合约代码
  var instrumentID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///开仓手续费率
  var openRatioByMoney: String = String()

  ///开仓手续费
  var openRatioByVolume: String = String()

  ///平仓手续费率
  var closeRatioByMoney: String = String()

  ///平仓手续费
  var closeRatioByVolume: String = String()

  ///平今手续费率
  var closeTodayRatioByMoney: String = String()

  ///平今手续费
  var closeTodayRatioByVolume: String = String()

  ///执行手续费率
  var strikeRatioByMoney: String = String()

  ///执行手续费
  var strikeRatioByVolume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///单个合约 查询最大报单数量请求 (1003->3100)
///CTP文档注：虽然ReqQryMaxOrderVolume可以查询可开，但是交易核心在计算的时候是没有
///  算手续费的，所以不完全准，计算逻辑是按照昨结算价计算的可开；如果需要精确结果的，
///  建议自行计算。另外，可平的查询是已经排除了冻结持仓的。
struct Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///合约代码
  var instrumentID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///投资者代码
  var investorID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///最大允许报单数量
  var maxVolume: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询交易参数 - 盈亏算法/保证金价格/可用是否包含平仓盈利/期权权利金价格类型 (3332)
struct Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///投资者代码
  var investorID: String = String()

  ///保证金价格类型 (1=昨结算价;2=最新价;3=成交均价;4=开仓价)
  var marginPriceType: String = String()

  ///盈亏算法 (1=浮盈浮亏都计算;2=浮盈不计，浮亏计;3=浮盈计，浮亏不计;4=浮盈浮亏都不计算)
  var algorithm: String = String()

  ///可用是否包含平仓盈利 (1=包含平仓盈利;2=不包含平仓盈利)
  var availIncludeCloseProfit: String = String()

  ///期权权利金价格类型 (1=昨结算价;2=开仓价;3=最新价与昨结算价较大值)
  var optionRoyaltyPriceType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///银期转账请求,银转期 (1011->4010)
struct Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///银行代码
  var bankID: String = String()

  ///银行账号
  var bankAccount: String = String()

  ///期货资金密码
  var password: String = String()

  ///银行密码
  var bankPassword: String = String()

  ///转账金额
  var tradeAmount: Double = 0

  ///投资者帐号
  var investorID: String = String()

  ///币种代码
  var currencyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///期货公司流水号
  var futureSerial: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///银期转账请求,期转银 (1011->4011)
struct Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///银行代码
  var bankID: String = String()

  ///银行账号
  var bankAccount: String = String()

  ///期货资金密码
  var password: String = String()

  ///银行密码
  var bankPassword: String = String()

  ///转账金额
  var tradeAmount: Double = 0

  ///投资者帐号
  var investorID: String = String()

  ///币种代码
  var currencyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///期货公司流水号
  var futureSerial: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///银期转账流水查询  (1012->4012) ?
struct Com_Gtjaqh_Trader_Task_QueryTransferSerialRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者账号
  var investorID: String = String()

  ///银行代码
  var bankID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryTransferSerialResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///交易流水详情
  var transferSerialFields: [Com_Gtjaqh_Trader_Task_TransferSerialField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询银行余额请求 (1013->4013)
struct Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///银行代码
  var bankID: String = String()

  ///银行账号
  var bankAccount: String = String()

  ///期货资金密码
  var password: String = String()

  ///银行密码
  var bankPassword: String = String()

  ///投资者帐号
  var investorID: String = String()

  ///币种代码
  var currencyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///银行可取金额
  var bankFetchAmount: String = String()

  ///期货公司流水号
  var futureSerial: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询银期签约关系 (452->4020) - register 首字母小写遵循ctp源命名
struct Com_Gtjaqh_Trader_Task_QueryAccountRegisterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者账号
  var accountID: String = String()

  ///银行代码 - 默认不填
  var bankID: String = String()

  ///银行分支机构代码 - 默认不填
  var bankBranchID: String = String()

  ///币种代码 - 默认不填
  var currencyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryAccountRegisterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔银期签约关系明细
  var accountregisterFields: [Com_Gtjaqh_Trader_Task_AccountregisterField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询签约银行 - 后台功能，不对前端提供 (4021)
struct Com_Gtjaqh_Trader_Task_QueryContractBankRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///银行代码 - 默认不填
  var bankID: String = String()

  ///银行分中心代码 - 默认不填
  var bankBrchID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryContractBankResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///各笔签约银行明细
  var contractBankFields: [Com_Gtjaqh_Trader_Task_ContractBankField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///查询监控中心用户令牌 - 密钥查询 (1532->4032)
struct Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者代码
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///期货公司代码
  var brokerID: String = String()

  ///期货公司统一编码
  var participantID: String = String()

  ///密钥编号
  var keyID: String = String()

  ///动态令牌
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///执行宣告录入 - 期权行权委托 (1601->8088)
struct Com_Gtjaqh_Trader_Task_ExecOrderInsertRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///合约代码
  var instrumentID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///投资者代码
  var investorID: String = String()

  ///数量
  var volume: Int32 = 0

  ///执行类型 (1=执行;2=放弃)
  var actionType: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///保留头寸申请的持仓方向 (1=净;2=多头;3=空头)
  var posiDirection: String = String()

  ///期权行权后生成的头寸是否自动平仓 - 自动平仓标志 (0=自动;1=非自动)
  var closeFlag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_ExecOrderInsertResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var execOrderSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///执行宣告操作请求 - 期权行权委托撤单 (28031->8089)
struct Com_Gtjaqh_Trader_Task_ExecOrderActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///投资者账号
  var investorID: String = String()

  ///期权委托编号
  var execOrderSysID: String = String()

  ///执行类型 (1=执行;2=放弃) - 推荐默认必填,femas上海地区市场必填
  var actionType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_ExecOrderActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var execOrderSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///期权自对冲请求录入 - 期权自对冲委托
struct Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///合约代码
  var instrumentID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///投资者代码
  var investorID: String = String()

  ///数量
  var volume: Int32 = 0

  ///期权行权的头寸是否自对冲 (1=自对冲期权仓位;2=保留期权仓位;3=自对冲卖方履约后的期货仓位)
  var optSelfCloseType: String = String()

  ///投机套保标志
  var hedgeFlag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var optionSelfCloseSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///期权自对冲操作请求 - 期权自对冲委托撤单
struct Com_Gtjaqh_Trader_Task_OptionSelfCloseActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///投资者账号
  var investorID: String = String()

  ///委托编号
  var optSelfCloseSysID: String = String()

  ///操作标志 (0=删除) - CTP 接口文档中此处可选"修改"标志，但注释中提示"支持删除，不支持修改"
  var actionFlag: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///履约头寸自对冲标志 (1=自对冲期权仓位;2=保留期权仓位;3=自对冲卖方履约后的期货仓位;4=保留卖方履约后的期货仓位) - FEMAS 大商所、广期所必填
  var optSelfCloseFlag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_OptionSelfCloseActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var optionSelfCloseSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交易委托下单 (1004->8888)
struct Com_Gtjaqh_Trader_Task_OrderInsertRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///合约代码
  var instrumentID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///委托价格
  var limitPrice: String = String()

  ///委托数量
  var volumeTotalOriginal: Int32 = 0

  ///投资者账号
  var investorID: String = String()

  ///报单价格条件类型 (1=任意价(市价);2=限价;G=五档价)
  var orderPriceType: String = String()

  ///有效期类型 (1=立即完成,否则撤销;2=本节有效;3=当日有效;4=指定日期前有效;5=撤销前有效;6=集合竞价有效)
  var timeCondition: String = String()

  ///成交量类型 (1=任何数量;2=最小数量;3=全部数量)
  var volumeCondition: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_OrderInsertResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var orderSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///交易委托撤单 (1005->8889)
struct Com_Gtjaqh_Trader_Task_OrderActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///报单编号
  var orderSysID: String = String()

  ///合约代码
  var instrumentID: String = String()

  ///交易所代码 (SHFE=上期所;CFFEX=中金所;CZCE=郑商所;DCE=大商所;INE=上海国际能源;GFEX=广期所)
  var exchangeID: String = String()

  ///投资者代码
  var investorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Gtjaqh_Trader_Task_OrderActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String = String()

  ///错误信息
  var errorMsg: String = String()

  ///委托编号
  var orderSysID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///成交回报 (111->8900)
struct Com_Gtjaqh_Trader_Task_TradeConfirmationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码 - 保持格式统一，此回报不会返回错误
  var errorID: String = String()

  ///错误信息 - 保持格式统一，此回报不会返回错误
  var errorMsg: String = String()

  ///成交结果
  var tradeField: Com_Gtjaqh_Trader_Task_TradeField {
    get {return _tradeField ?? Com_Gtjaqh_Trader_Task_TradeField()}
    set {_tradeField = newValue}
  }
  /// Returns true if `tradeField` has been explicitly set.
  var hasTradeField: Bool {return self._tradeField != nil}
  /// Clears the value of `tradeField`. Subsequent reads from it will return its default value.
  mutating func clearTradeField() {self._tradeField = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradeField: Com_Gtjaqh_Trader_Task_TradeField? = nil
}

///委托回报 (8901)
struct Com_Gtjaqh_Trader_Task_OrderConfirmationResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///错误代码
  var errorID: String {
    get {return _storage._errorID}
    set {_uniqueStorage()._errorID = newValue}
  }

  ///错误信息
  var errorMsg: String {
    get {return _storage._errorMsg}
    set {_uniqueStorage()._errorMsg = newValue}
  }

  ///委托明细
  var orderField: Com_Gtjaqh_Trader_Task_OrderField {
    get {return _storage._orderField ?? Com_Gtjaqh_Trader_Task_OrderField()}
    set {_uniqueStorage()._orderField = newValue}
  }
  /// Returns true if `orderField` has been explicitly set.
  var hasOrderField: Bool {return _storage._orderField != nil}
  /// Clears the value of `orderField`. Subsequent reads from it will return its default value.
  mutating func clearOrderField() {_uniqueStorage()._orderField = nil}

  ///委托类型 (1=委托报单;2=委托撤单)
  var orderType: String {
    get {return _storage._orderType}
    set {_uniqueStorage()._orderType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.gtjaqh.trader.task"

extension Com_Gtjaqh_Trader_Task_SystemHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SystemHeartbeatRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_SystemHeartbeatRequest, rhs: Com_Gtjaqh_Trader_Task_SystemHeartbeatRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_SystemHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SystemHeartbeatResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_SystemHeartbeatResponse, rhs: Com_Gtjaqh_Trader_Task_SystemHeartbeatResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_SystemQueryCacheConfirmationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SystemQueryCacheConfirmationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_SystemQueryCacheConfirmationResponse, rhs: Com_Gtjaqh_Trader_Task_SystemQueryCacheConfirmationResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLoginRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "password"),
    3: .standard(proto: "app_id"),
    4: .standard(proto: "auth_code"),
    5: .standard(proto: "client_sys_info"),
    6: .standard(proto: "mobile_uuid"),
    7: .standard(proto: "trade_token_required"),
    8: .standard(proto: "x_os_version"),
    9: .standard(proto: "x_model"),
    10: .same(proto: "ip"),
    11: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.clientSysInfo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mobileUuid) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.tradeTokenRequired) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.xOsVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.xModel) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 3)
    }
    if !self.authCode.isEmpty {
      try visitor.visitSingularStringField(value: self.authCode, fieldNumber: 4)
    }
    if !self.clientSysInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSysInfo, fieldNumber: 5)
    }
    if !self.mobileUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.mobileUuid, fieldNumber: 6)
    }
    if !self.tradeTokenRequired.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeTokenRequired, fieldNumber: 7)
    }
    if !self.xOsVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.xOsVersion, fieldNumber: 8)
    }
    if !self.xModel.isEmpty {
      try visitor.visitSingularStringField(value: self.xModel, fieldNumber: 9)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 10)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserLoginRequest, rhs: Com_Gtjaqh_Trader_Task_UserLoginRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.authCode != rhs.authCode {return false}
    if lhs.clientSysInfo != rhs.clientSysInfo {return false}
    if lhs.mobileUuid != rhs.mobileUuid {return false}
    if lhs.tradeTokenRequired != rhs.tradeTokenRequired {return false}
    if lhs.xOsVersion != rhs.xOsVersion {return false}
    if lhs.xModel != rhs.xModel {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLoginResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "alert_info"),
    4: .standard(proto: "init_password_flag"),
    5: .standard(proto: "trading_day"),
    6: .standard(proto: "settlement_info_confirmed"),
    7: .standard(proto: "user_id"),
    8: .standard(proto: "trade_token"),
    9: .standard(proto: "query_token"),
    10: .standard(proto: "broker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.alertInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.initPasswordFlag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tradingDay) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.settlementInfoConfirmed) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.tradeToken) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.queryToken) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.brokerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.alertInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.alertInfo, fieldNumber: 3)
    }
    if !self.initPasswordFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.initPasswordFlag, fieldNumber: 4)
    }
    if !self.tradingDay.isEmpty {
      try visitor.visitSingularStringField(value: self.tradingDay, fieldNumber: 5)
    }
    if !self.settlementInfoConfirmed.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementInfoConfirmed, fieldNumber: 6)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 7)
    }
    if !self.tradeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeToken, fieldNumber: 8)
    }
    if !self.queryToken.isEmpty {
      try visitor.visitSingularStringField(value: self.queryToken, fieldNumber: 9)
    }
    if !self.brokerID.isEmpty {
      try visitor.visitSingularStringField(value: self.brokerID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserLoginResponse, rhs: Com_Gtjaqh_Trader_Task_UserLoginResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.alertInfo != rhs.alertInfo {return false}
    if lhs.initPasswordFlag != rhs.initPasswordFlag {return false}
    if lhs.tradingDay != rhs.tradingDay {return false}
    if lhs.settlementInfoConfirmed != rhs.settlementInfoConfirmed {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.tradeToken != rhs.tradeToken {return false}
    if lhs.queryToken != rhs.queryToken {return false}
    if lhs.brokerID != rhs.brokerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserReconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserReconnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_token"),
    2: .standard(proto: "query_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tradeToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.queryToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tradeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeToken, fieldNumber: 1)
    }
    if !self.queryToken.isEmpty {
      try visitor.visitSingularStringField(value: self.queryToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserReconnectRequest, rhs: Com_Gtjaqh_Trader_Task_UserReconnectRequest) -> Bool {
    if lhs.tradeToken != rhs.tradeToken {return false}
    if lhs.queryToken != rhs.queryToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserReconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserReconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserReconnectResponse, rhs: Com_Gtjaqh_Trader_Task_UserReconnectResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserLogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLogoutRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserLogoutRequest, rhs: Com_Gtjaqh_Trader_Task_UserLogoutRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserLogoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLogoutResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserLogoutResponse, rhs: Com_Gtjaqh_Trader_Task_UserLogoutResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserSettlementInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSettlementInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "trading_day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tradingDay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.tradingDay.isEmpty {
      try visitor.visitSingularStringField(value: self.tradingDay, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoRequest, rhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.tradingDay != rhs.tradingDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserSettlementInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSettlementInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoResponse, rhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSettlementInfoConfirmRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmRequest, rhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSettlementInfoConfirmResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "confirm_date"),
    4: .standard(proto: "confirm_time"),
    5: .standard(proto: "settlement_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.confirmDate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.confirmTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.settlementID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.confirmDate.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmDate, fieldNumber: 3)
    }
    if !self.confirmTime.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmTime, fieldNumber: 4)
    }
    if !self.settlementID.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmResponse, rhs: Com_Gtjaqh_Trader_Task_UserSettlementInfoConfirmResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.confirmDate != rhs.confirmDate {return false}
    if lhs.confirmTime != rhs.confirmTime {return false}
    if lhs.settlementID != rhs.settlementID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserPasswordUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPasswordUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "old_password"),
    3: .standard(proto: "new_password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 2)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserPasswordUpdateRequest, rhs: Com_Gtjaqh_Trader_Task_UserPasswordUpdateRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserPasswordUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPasswordUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserPasswordUpdateResponse, rhs: Com_Gtjaqh_Trader_Task_UserPasswordUpdateResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTradingAccountPasswordUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "old_password"),
    3: .standard(proto: "new_password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 2)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateRequest, rhs: Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTradingAccountPasswordUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateResponse, rhs: Com_Gtjaqh_Trader_Task_UserTradingAccountPasswordUpdateResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryUsersOnlineRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryUsersOnlineRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryUsersOnlineRequest, rhs: Com_Gtjaqh_Trader_Task_QueryUsersOnlineRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryUsersOnlineResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryUsersOnlineResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryUsersOnlineResponse, rhs: Com_Gtjaqh_Trader_Task_QueryUsersOnlineResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryPositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPositionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "request_num"),
    3: .standard(proto: "instrument_id"),
    4: .standard(proto: "is_options_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.requestNum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isOptionsOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if self.requestNum != 0 {
      try visitor.visitSingularInt32Field(value: self.requestNum, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    if self.isOptionsOnly != false {
      try visitor.visitSingularBoolField(value: self.isOptionsOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryPositionRequest, rhs: Com_Gtjaqh_Trader_Task_QueryPositionRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.requestNum != rhs.requestNum {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.isOptionsOnly != rhs.isOptionsOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryPositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPositionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "position_fields"),
    4: .standard(proto: "option_position_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.positionFields) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.optionPositionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.positionFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positionFields, fieldNumber: 3)
    }
    if !self.optionPositionFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.optionPositionFields, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryPositionResponse, rhs: Com_Gtjaqh_Trader_Task_QueryPositionResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.positionFields != rhs.positionFields {return false}
    if lhs.optionPositionFields != rhs.optionPositionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "request_num"),
    3: .standard(proto: "instrument_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.requestNum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if self.requestNum != 0 {
      try visitor.visitSingularInt32Field(value: self.requestNum, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOrderRequest, rhs: Com_Gtjaqh_Trader_Task_QueryOrderRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.requestNum != rhs.requestNum {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "order_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orderFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.orderFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOrderResponse, rhs: Com_Gtjaqh_Trader_Task_QueryOrderResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.orderFields != rhs.orderFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "request_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.requestNum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if self.requestNum != 0 {
      try visitor.visitSingularInt32Field(value: self.requestNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradeRequest, rhs: Com_Gtjaqh_Trader_Task_QueryTradeRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.requestNum != rhs.requestNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "trade_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tradeFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.tradeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradeResponse, rhs: Com_Gtjaqh_Trader_Task_QueryTradeResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.tradeFields != rhs.tradeFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryExecOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExecOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "exchange_id"),
    4: .standard(proto: "exec_order_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.execOrderSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 3)
    }
    if !self.execOrderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.execOrderSysID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryExecOrderRequest, rhs: Com_Gtjaqh_Trader_Task_QueryExecOrderRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.execOrderSysID != rhs.execOrderSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryExecOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExecOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "exec_order_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.execOrderFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.execOrderFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.execOrderFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryExecOrderResponse, rhs: Com_Gtjaqh_Trader_Task_QueryExecOrderResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.execOrderFields != rhs.execOrderFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionSelfCloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "exchange_id"),
    4: .standard(proto: "option_self_close_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.optionSelfCloseSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 3)
    }
    if !self.optionSelfCloseSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionSelfCloseSysID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseRequest, rhs: Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.optionSelfCloseSysID != rhs.optionSelfCloseSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionSelfCloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "option_self_close_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.optionSelfCloseFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.optionSelfCloseFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.optionSelfCloseFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseResponse, rhs: Com_Gtjaqh_Trader_Task_QueryOptionSelfCloseResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.optionSelfCloseFields != rhs.optionSelfCloseFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradingCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradingCodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradingCodeRequest, rhs: Com_Gtjaqh_Trader_Task_QueryTradingCodeRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradingCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradingCodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "trading_codes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tradingCodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.tradingCodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradingCodes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradingCodeResponse, rhs: Com_Gtjaqh_Trader_Task_QueryTradingCodeResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.tradingCodes != rhs.tradingCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradingAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradingAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradingAccountRequest, rhs: Com_Gtjaqh_Trader_Task_QueryTradingAccountRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTradingAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradingAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .same(proto: "available"),
    4: .standard(proto: "withdraw_quota"),
    5: .standard(proto: "frozen_cash"),
    6: .standard(proto: "position_profit"),
    7: .standard(proto: "position_profit_rate"),
    8: .standard(proto: "close_profit"),
    9: .standard(proto: "close_profit_rate"),
    10: .standard(proto: "frozen_margin"),
    11: .standard(proto: "curr_margin"),
    12: .standard(proto: "risk_rate"),
    13: .standard(proto: "pre_balance"),
    14: .same(proto: "balance"),
    15: .standard(proto: "fund_mortgage_in"),
    16: .standard(proto: "fund_mortgage_out"),
    17: .same(proto: "commission"),
    18: .standard(proto: "frozen_commission"),
    19: .standard(proto: "pre_mortgage"),
    20: .same(proto: "mortgage"),
    21: .standard(proto: "fund_mortgage_available"),
    22: .standard(proto: "mortgageable_fund"),
    23: .standard(proto: "currency_id"),
    24: .standard(proto: "update_time"),
    25: .same(proto: "deposit"),
    26: .same(proto: "withdraw"),
    27: .standard(proto: "delivery_margin"),
    28: .standard(proto: "currency_id_name"),
    29: .standard(proto: "total_frozen_money"),
  ]

  fileprivate class _StorageClass {
    var _errorID: String = String()
    var _errorMsg: String = String()
    var _available: String = String()
    var _withdrawQuota: String = String()
    var _frozenCash: String = String()
    var _positionProfit: String = String()
    var _positionProfitRate: String = String()
    var _closeProfit: String = String()
    var _closeProfitRate: String = String()
    var _frozenMargin: String = String()
    var _currMargin: String = String()
    var _riskRate: String = String()
    var _preBalance: String = String()
    var _balance: String = String()
    var _fundMortgageIn: String = String()
    var _fundMortgageOut: String = String()
    var _commission: String = String()
    var _frozenCommission: String = String()
    var _preMortgage: String = String()
    var _mortgage: String = String()
    var _fundMortgageAvailable: String = String()
    var _mortgageableFund: String = String()
    var _currencyID: String = String()
    var _updateTime: String = String()
    var _deposit: String = String()
    var _withdraw: String = String()
    var _deliveryMargin: String = String()
    var _currencyIDName: String = String()
    var _totalFrozenMoney: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _errorID = source._errorID
      _errorMsg = source._errorMsg
      _available = source._available
      _withdrawQuota = source._withdrawQuota
      _frozenCash = source._frozenCash
      _positionProfit = source._positionProfit
      _positionProfitRate = source._positionProfitRate
      _closeProfit = source._closeProfit
      _closeProfitRate = source._closeProfitRate
      _frozenMargin = source._frozenMargin
      _currMargin = source._currMargin
      _riskRate = source._riskRate
      _preBalance = source._preBalance
      _balance = source._balance
      _fundMortgageIn = source._fundMortgageIn
      _fundMortgageOut = source._fundMortgageOut
      _commission = source._commission
      _frozenCommission = source._frozenCommission
      _preMortgage = source._preMortgage
      _mortgage = source._mortgage
      _fundMortgageAvailable = source._fundMortgageAvailable
      _mortgageableFund = source._mortgageableFund
      _currencyID = source._currencyID
      _updateTime = source._updateTime
      _deposit = source._deposit
      _withdraw = source._withdraw
      _deliveryMargin = source._deliveryMargin
      _currencyIDName = source._currencyIDName
      _totalFrozenMoney = source._totalFrozenMoney
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._errorID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._errorMsg) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._available) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._withdrawQuota) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._frozenCash) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._positionProfit) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._positionProfitRate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._closeProfit) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._closeProfitRate) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._frozenMargin) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._currMargin) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._riskRate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._preBalance) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._balance) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._fundMortgageIn) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._fundMortgageOut) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._commission) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._frozenCommission) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._preMortgage) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._mortgage) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._fundMortgageAvailable) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._mortgageableFund) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._currencyID) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._updateTime) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._deposit) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._withdraw) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._deliveryMargin) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._currencyIDName) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._totalFrozenMoney) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._errorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorID, fieldNumber: 1)
      }
      if !_storage._errorMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMsg, fieldNumber: 2)
      }
      if !_storage._available.isEmpty {
        try visitor.visitSingularStringField(value: _storage._available, fieldNumber: 3)
      }
      if !_storage._withdrawQuota.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawQuota, fieldNumber: 4)
      }
      if !_storage._frozenCash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._frozenCash, fieldNumber: 5)
      }
      if !_storage._positionProfit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionProfit, fieldNumber: 6)
      }
      if !_storage._positionProfitRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionProfitRate, fieldNumber: 7)
      }
      if !_storage._closeProfit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeProfit, fieldNumber: 8)
      }
      if !_storage._closeProfitRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeProfitRate, fieldNumber: 9)
      }
      if !_storage._frozenMargin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._frozenMargin, fieldNumber: 10)
      }
      if !_storage._currMargin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currMargin, fieldNumber: 11)
      }
      if !_storage._riskRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._riskRate, fieldNumber: 12)
      }
      if !_storage._preBalance.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preBalance, fieldNumber: 13)
      }
      if !_storage._balance.isEmpty {
        try visitor.visitSingularStringField(value: _storage._balance, fieldNumber: 14)
      }
      if !_storage._fundMortgageIn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fundMortgageIn, fieldNumber: 15)
      }
      if !_storage._fundMortgageOut.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fundMortgageOut, fieldNumber: 16)
      }
      if !_storage._commission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._commission, fieldNumber: 17)
      }
      if !_storage._frozenCommission.isEmpty {
        try visitor.visitSingularStringField(value: _storage._frozenCommission, fieldNumber: 18)
      }
      if !_storage._preMortgage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preMortgage, fieldNumber: 19)
      }
      if !_storage._mortgage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mortgage, fieldNumber: 20)
      }
      if !_storage._fundMortgageAvailable.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fundMortgageAvailable, fieldNumber: 21)
      }
      if !_storage._mortgageableFund.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mortgageableFund, fieldNumber: 22)
      }
      if !_storage._currencyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currencyID, fieldNumber: 23)
      }
      if !_storage._updateTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updateTime, fieldNumber: 24)
      }
      if !_storage._deposit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deposit, fieldNumber: 25)
      }
      if !_storage._withdraw.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdraw, fieldNumber: 26)
      }
      if !_storage._deliveryMargin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deliveryMargin, fieldNumber: 27)
      }
      if !_storage._currencyIDName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currencyIDName, fieldNumber: 28)
      }
      if !_storage._totalFrozenMoney.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalFrozenMoney, fieldNumber: 29)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTradingAccountResponse, rhs: Com_Gtjaqh_Trader_Task_QueryTradingAccountResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._errorID != rhs_storage._errorID {return false}
        if _storage._errorMsg != rhs_storage._errorMsg {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._withdrawQuota != rhs_storage._withdrawQuota {return false}
        if _storage._frozenCash != rhs_storage._frozenCash {return false}
        if _storage._positionProfit != rhs_storage._positionProfit {return false}
        if _storage._positionProfitRate != rhs_storage._positionProfitRate {return false}
        if _storage._closeProfit != rhs_storage._closeProfit {return false}
        if _storage._closeProfitRate != rhs_storage._closeProfitRate {return false}
        if _storage._frozenMargin != rhs_storage._frozenMargin {return false}
        if _storage._currMargin != rhs_storage._currMargin {return false}
        if _storage._riskRate != rhs_storage._riskRate {return false}
        if _storage._preBalance != rhs_storage._preBalance {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._fundMortgageIn != rhs_storage._fundMortgageIn {return false}
        if _storage._fundMortgageOut != rhs_storage._fundMortgageOut {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._frozenCommission != rhs_storage._frozenCommission {return false}
        if _storage._preMortgage != rhs_storage._preMortgage {return false}
        if _storage._mortgage != rhs_storage._mortgage {return false}
        if _storage._fundMortgageAvailable != rhs_storage._fundMortgageAvailable {return false}
        if _storage._mortgageableFund != rhs_storage._mortgageableFund {return false}
        if _storage._currencyID != rhs_storage._currencyID {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._deposit != rhs_storage._deposit {return false}
        if _storage._withdraw != rhs_storage._withdraw {return false}
        if _storage._deliveryMargin != rhs_storage._deliveryMargin {return false}
        if _storage._currencyIDName != rhs_storage._currencyIDName {return false}
        if _storage._totalFrozenMoney != rhs_storage._totalFrozenMoney {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryInstrumentMarginRateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "hedge_flag"),
    4: .same(proto: "direction"),
    5: .standard(proto: "exchange_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 3)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 4)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateRequest, rhs: Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryInstrumentMarginRateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "hedge_flag"),
    4: .standard(proto: "instrument_id"),
    5: .same(proto: "direction"),
    6: .standard(proto: "margin_ratio_by_money"),
    7: .standard(proto: "margin_ratio_by_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.marginRatioByMoney) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marginRatioByVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 3)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 4)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 5)
    }
    if !self.marginRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.marginRatioByMoney, fieldNumber: 6)
    }
    if !self.marginRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.marginRatioByVolume, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateResponse, rhs: Com_Gtjaqh_Trader_Task_QueryInstrumentMarginRateResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.marginRatioByMoney != rhs.marginRatioByMoney {return false}
    if lhs.marginRatioByVolume != rhs.marginRatioByVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionInstrTradeCostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "hedge_flag"),
    4: .standard(proto: "input_price"),
    5: .standard(proto: "underlying_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.inputPrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.underlyingPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 3)
    }
    if !self.inputPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.inputPrice, fieldNumber: 4)
    }
    if !self.underlyingPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.underlyingPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostRequest, rhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.inputPrice != rhs.inputPrice {return false}
    if lhs.underlyingPrice != rhs.underlyingPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionInstrTradeCostResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "hedge_flag"),
    4: .standard(proto: "fixed_margin"),
    5: .standard(proto: "mini_margin"),
    6: .same(proto: "royalty"),
    7: .standard(proto: "exch_fixed_margin"),
    8: .standard(proto: "exch_mini_margin"),
    9: .standard(proto: "instrument_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fixedMargin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.miniMargin) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.royalty) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.exchFixedMargin) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.exchMiniMargin) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 3)
    }
    if !self.fixedMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedMargin, fieldNumber: 4)
    }
    if !self.miniMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.miniMargin, fieldNumber: 5)
    }
    if !self.royalty.isEmpty {
      try visitor.visitSingularStringField(value: self.royalty, fieldNumber: 6)
    }
    if !self.exchFixedMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.exchFixedMargin, fieldNumber: 7)
    }
    if !self.exchMiniMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.exchMiniMargin, fieldNumber: 8)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostResponse, rhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrTradeCostResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.fixedMargin != rhs.fixedMargin {return false}
    if lhs.miniMargin != rhs.miniMargin {return false}
    if lhs.royalty != rhs.royalty {return false}
    if lhs.exchFixedMargin != rhs.exchFixedMargin {return false}
    if lhs.exchMiniMargin != rhs.exchMiniMargin {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryInstrumentCommissionRateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateRequest, rhs: Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryInstrumentCommissionRateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "open_ratio_by_money"),
    4: .standard(proto: "open_ratio_by_volume"),
    5: .standard(proto: "close_ratio_by_money"),
    6: .standard(proto: "close_ratio_by_volume"),
    7: .standard(proto: "close_today_ratio_by_money"),
    8: .standard(proto: "close_today_ratio_by_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.openRatioByMoney) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.openRatioByVolume) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.closeRatioByMoney) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.closeRatioByVolume) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.closeTodayRatioByMoney) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.closeTodayRatioByVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.openRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.openRatioByMoney, fieldNumber: 3)
    }
    if !self.openRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.openRatioByVolume, fieldNumber: 4)
    }
    if !self.closeRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.closeRatioByMoney, fieldNumber: 5)
    }
    if !self.closeRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.closeRatioByVolume, fieldNumber: 6)
    }
    if !self.closeTodayRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTodayRatioByMoney, fieldNumber: 7)
    }
    if !self.closeTodayRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTodayRatioByVolume, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateResponse, rhs: Com_Gtjaqh_Trader_Task_QueryInstrumentCommissionRateResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.openRatioByMoney != rhs.openRatioByMoney {return false}
    if lhs.openRatioByVolume != rhs.openRatioByVolume {return false}
    if lhs.closeRatioByMoney != rhs.closeRatioByMoney {return false}
    if lhs.closeRatioByVolume != rhs.closeRatioByVolume {return false}
    if lhs.closeTodayRatioByMoney != rhs.closeTodayRatioByMoney {return false}
    if lhs.closeTodayRatioByVolume != rhs.closeTodayRatioByVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionInstrCommRateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "instrument_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateRequest, rhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptionInstrCommRateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "open_ratio_by_money"),
    4: .standard(proto: "open_ratio_by_volume"),
    5: .standard(proto: "close_ratio_by_money"),
    6: .standard(proto: "close_ratio_by_volume"),
    7: .standard(proto: "close_today_ratio_by_money"),
    8: .standard(proto: "close_today_ratio_by_volume"),
    9: .standard(proto: "strike_ratio_by_money"),
    10: .standard(proto: "strike_ratio_by_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.openRatioByMoney) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.openRatioByVolume) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.closeRatioByMoney) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.closeRatioByVolume) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.closeTodayRatioByMoney) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.closeTodayRatioByVolume) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.strikeRatioByMoney) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.strikeRatioByVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.openRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.openRatioByMoney, fieldNumber: 3)
    }
    if !self.openRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.openRatioByVolume, fieldNumber: 4)
    }
    if !self.closeRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.closeRatioByMoney, fieldNumber: 5)
    }
    if !self.closeRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.closeRatioByVolume, fieldNumber: 6)
    }
    if !self.closeTodayRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTodayRatioByMoney, fieldNumber: 7)
    }
    if !self.closeTodayRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.closeTodayRatioByVolume, fieldNumber: 8)
    }
    if !self.strikeRatioByMoney.isEmpty {
      try visitor.visitSingularStringField(value: self.strikeRatioByMoney, fieldNumber: 9)
    }
    if !self.strikeRatioByVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.strikeRatioByVolume, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateResponse, rhs: Com_Gtjaqh_Trader_Task_QueryOptionInstrCommRateResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.openRatioByMoney != rhs.openRatioByMoney {return false}
    if lhs.openRatioByVolume != rhs.openRatioByVolume {return false}
    if lhs.closeRatioByMoney != rhs.closeRatioByMoney {return false}
    if lhs.closeRatioByVolume != rhs.closeRatioByVolume {return false}
    if lhs.closeTodayRatioByMoney != rhs.closeTodayRatioByMoney {return false}
    if lhs.closeTodayRatioByVolume != rhs.closeTodayRatioByVolume {return false}
    if lhs.strikeRatioByMoney != rhs.strikeRatioByMoney {return false}
    if lhs.strikeRatioByVolume != rhs.strikeRatioByVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxOrderVolumeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .standard(proto: "hedge_flag"),
    3: .same(proto: "direction"),
    4: .standard(proto: "offset_flag"),
    5: .standard(proto: "investor_id"),
    6: .standard(proto: "exchange_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 2)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 3)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 4)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 5)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeRequest, rhs: Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxOrderVolumeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "instrument_id"),
    4: .standard(proto: "hedge_flag"),
    5: .same(proto: "direction"),
    6: .standard(proto: "offset_flag"),
    7: .standard(proto: "max_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.maxVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 4)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 5)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 6)
    }
    if self.maxVolume != 0 {
      try visitor.visitSingularInt32Field(value: self.maxVolume, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeResponse, rhs: Com_Gtjaqh_Trader_Task_QueryMaxOrderVolumeResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.maxVolume != rhs.maxVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBrokerTradingParamsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsRequest, rhs: Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBrokerTradingParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "investor_id"),
    4: .standard(proto: "margin_price_type"),
    5: .same(proto: "algorithm"),
    6: .standard(proto: "avail_include_close_profit"),
    7: .standard(proto: "option_royalty_price_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.marginPriceType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.algorithm) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.availIncludeCloseProfit) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.optionRoyaltyPriceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 3)
    }
    if !self.marginPriceType.isEmpty {
      try visitor.visitSingularStringField(value: self.marginPriceType, fieldNumber: 4)
    }
    if !self.algorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.algorithm, fieldNumber: 5)
    }
    if !self.availIncludeCloseProfit.isEmpty {
      try visitor.visitSingularStringField(value: self.availIncludeCloseProfit, fieldNumber: 6)
    }
    if !self.optionRoyaltyPriceType.isEmpty {
      try visitor.visitSingularStringField(value: self.optionRoyaltyPriceType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsResponse, rhs: Com_Gtjaqh_Trader_Task_QueryBrokerTradingParamsResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.marginPriceType != rhs.marginPriceType {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.availIncludeCloseProfit != rhs.availIncludeCloseProfit {return false}
    if lhs.optionRoyaltyPriceType != rhs.optionRoyaltyPriceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromBankToFutureByFutureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bank_id"),
    2: .standard(proto: "bank_account"),
    3: .same(proto: "password"),
    4: .standard(proto: "bank_password"),
    5: .standard(proto: "trade_amount"),
    6: .standard(proto: "investor_id"),
    7: .standard(proto: "currency_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankAccount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bankPassword) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.tradeAmount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 1)
    }
    if !self.bankAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankAccount, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if !self.bankPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.bankPassword, fieldNumber: 4)
    }
    if self.tradeAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.tradeAmount, fieldNumber: 5)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 6)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureRequest, rhs: Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureRequest) -> Bool {
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankAccount != rhs.bankAccount {return false}
    if lhs.password != rhs.password {return false}
    if lhs.bankPassword != rhs.bankPassword {return false}
    if lhs.tradeAmount != rhs.tradeAmount {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromBankToFutureByFutureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "future_serial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.futureSerial) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.futureSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.futureSerial, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureResponse, rhs: Com_Gtjaqh_Trader_Task_FromBankToFutureByFutureResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.futureSerial != rhs.futureSerial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromFutureToBankByFutureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bank_id"),
    2: .standard(proto: "bank_account"),
    3: .same(proto: "password"),
    4: .standard(proto: "bank_password"),
    5: .standard(proto: "trade_amount"),
    6: .standard(proto: "investor_id"),
    7: .standard(proto: "currency_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankAccount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bankPassword) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.tradeAmount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 1)
    }
    if !self.bankAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankAccount, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if !self.bankPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.bankPassword, fieldNumber: 4)
    }
    if self.tradeAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.tradeAmount, fieldNumber: 5)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 6)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureRequest, rhs: Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureRequest) -> Bool {
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankAccount != rhs.bankAccount {return false}
    if lhs.password != rhs.password {return false}
    if lhs.bankPassword != rhs.bankPassword {return false}
    if lhs.tradeAmount != rhs.tradeAmount {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromFutureToBankByFutureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "future_serial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.futureSerial) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.futureSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.futureSerial, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureResponse, rhs: Com_Gtjaqh_Trader_Task_FromFutureToBankByFutureResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.futureSerial != rhs.futureSerial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTransferSerialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTransferSerialRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
    2: .standard(proto: "bank_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTransferSerialRequest, rhs: Com_Gtjaqh_Trader_Task_QueryTransferSerialRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.bankID != rhs.bankID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryTransferSerialResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTransferSerialResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "transfer_serial_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transferSerialFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.transferSerialFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transferSerialFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryTransferSerialResponse, rhs: Com_Gtjaqh_Trader_Task_QueryTransferSerialResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.transferSerialFields != rhs.transferSerialFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBankAccountMoneyByFutureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bank_id"),
    2: .standard(proto: "bank_account"),
    3: .same(proto: "password"),
    4: .standard(proto: "bank_password"),
    5: .standard(proto: "investor_id"),
    6: .standard(proto: "currency_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankAccount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bankPassword) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 1)
    }
    if !self.bankAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankAccount, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if !self.bankPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.bankPassword, fieldNumber: 4)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 5)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureRequest, rhs: Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureRequest) -> Bool {
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankAccount != rhs.bankAccount {return false}
    if lhs.password != rhs.password {return false}
    if lhs.bankPassword != rhs.bankPassword {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBankAccountMoneyByFutureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "bank_fetch_amount"),
    4: .standard(proto: "future_serial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankFetchAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.futureSerial) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.bankFetchAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankFetchAmount, fieldNumber: 3)
    }
    if !self.futureSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.futureSerial, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureResponse, rhs: Com_Gtjaqh_Trader_Task_QueryBankAccountMoneyByFutureResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.bankFetchAmount != rhs.bankFetchAmount {return false}
    if lhs.futureSerial != rhs.futureSerial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryAccountRegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountRegisterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "bank_id"),
    3: .standard(proto: "bank_branch_id"),
    4: .standard(proto: "currency_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankBranchID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 2)
    }
    if !self.bankBranchID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankBranchID, fieldNumber: 3)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryAccountRegisterRequest, rhs: Com_Gtjaqh_Trader_Task_QueryAccountRegisterRequest) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankBranchID != rhs.bankBranchID {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryAccountRegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountRegisterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "accountregister_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accountregisterFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.accountregisterFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountregisterFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryAccountRegisterResponse, rhs: Com_Gtjaqh_Trader_Task_QueryAccountRegisterResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.accountregisterFields != rhs.accountregisterFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryContractBankRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractBankRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bank_id"),
    2: .standard(proto: "bank_brch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankBrchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 1)
    }
    if !self.bankBrchID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankBrchID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryContractBankRequest, rhs: Com_Gtjaqh_Trader_Task_QueryContractBankRequest) -> Bool {
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankBrchID != rhs.bankBrchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryContractBankResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractBankResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "contract_bank_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contractBankFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.contractBankFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractBankFields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryContractBankResponse, rhs: Com_Gtjaqh_Trader_Task_QueryContractBankResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.contractBankFields != rhs.contractBankFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCFMMCTradingAccountTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenRequest, rhs: Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenRequest) -> Bool {
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCFMMCTradingAccountTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "broker_id"),
    4: .standard(proto: "participant_id"),
    5: .standard(proto: "key_id"),
    6: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.brokerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.brokerID.isEmpty {
      try visitor.visitSingularStringField(value: self.brokerID, fieldNumber: 3)
    }
    if !self.participantID.isEmpty {
      try visitor.visitSingularStringField(value: self.participantID, fieldNumber: 4)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 5)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenResponse, rhs: Com_Gtjaqh_Trader_Task_QueryCFMMCTradingAccountTokenResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.brokerID != rhs.brokerID {return false}
    if lhs.participantID != rhs.participantID {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ExecOrderInsertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecOrderInsertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .standard(proto: "exchange_id"),
    3: .standard(proto: "investor_id"),
    4: .same(proto: "volume"),
    5: .standard(proto: "action_type"),
    6: .standard(proto: "hedge_flag"),
    7: .standard(proto: "offset_flag"),
    8: .standard(proto: "posi_direction"),
    9: .standard(proto: "close_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.volume) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.actionType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.posiDirection) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.closeFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 2)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 3)
    }
    if self.volume != 0 {
      try visitor.visitSingularInt32Field(value: self.volume, fieldNumber: 4)
    }
    if !self.actionType.isEmpty {
      try visitor.visitSingularStringField(value: self.actionType, fieldNumber: 5)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 6)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 7)
    }
    if !self.posiDirection.isEmpty {
      try visitor.visitSingularStringField(value: self.posiDirection, fieldNumber: 8)
    }
    if !self.closeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.closeFlag, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ExecOrderInsertRequest, rhs: Com_Gtjaqh_Trader_Task_ExecOrderInsertRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.actionType != rhs.actionType {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.posiDirection != rhs.posiDirection {return false}
    if lhs.closeFlag != rhs.closeFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ExecOrderInsertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecOrderInsertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "exec_order_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.execOrderSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.execOrderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.execOrderSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ExecOrderInsertResponse, rhs: Com_Gtjaqh_Trader_Task_ExecOrderInsertResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.execOrderSysID != rhs.execOrderSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ExecOrderActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecOrderActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "investor_id"),
    3: .standard(proto: "exec_order_sys_id"),
    4: .standard(proto: "action_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.execOrderSysID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.actionType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 2)
    }
    if !self.execOrderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.execOrderSysID, fieldNumber: 3)
    }
    if !self.actionType.isEmpty {
      try visitor.visitSingularStringField(value: self.actionType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ExecOrderActionRequest, rhs: Com_Gtjaqh_Trader_Task_ExecOrderActionRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.execOrderSysID != rhs.execOrderSysID {return false}
    if lhs.actionType != rhs.actionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ExecOrderActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecOrderActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "exec_order_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.execOrderSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.execOrderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.execOrderSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ExecOrderActionResponse, rhs: Com_Gtjaqh_Trader_Task_ExecOrderActionResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.execOrderSysID != rhs.execOrderSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OptionSelfCloseInsertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .standard(proto: "exchange_id"),
    3: .standard(proto: "investor_id"),
    4: .same(proto: "volume"),
    5: .standard(proto: "opt_self_close_type"),
    6: .standard(proto: "hedge_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.volume) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.optSelfCloseType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 2)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 3)
    }
    if self.volume != 0 {
      try visitor.visitSingularInt32Field(value: self.volume, fieldNumber: 4)
    }
    if !self.optSelfCloseType.isEmpty {
      try visitor.visitSingularStringField(value: self.optSelfCloseType, fieldNumber: 5)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertRequest, rhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.optSelfCloseType != rhs.optSelfCloseType {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OptionSelfCloseInsertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "option_self_close_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.optionSelfCloseSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.optionSelfCloseSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionSelfCloseSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertResponse, rhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseInsertResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.optionSelfCloseSysID != rhs.optionSelfCloseSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OptionSelfCloseActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OptionSelfCloseActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "investor_id"),
    3: .standard(proto: "opt_self_close_sys_id"),
    4: .standard(proto: "action_flag"),
    5: .standard(proto: "instrument_id"),
    6: .standard(proto: "opt_self_close_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.optSelfCloseSysID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.actionFlag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.optSelfCloseFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 2)
    }
    if !self.optSelfCloseSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.optSelfCloseSysID, fieldNumber: 3)
    }
    if !self.actionFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.actionFlag, fieldNumber: 4)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 5)
    }
    if !self.optSelfCloseFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.optSelfCloseFlag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseActionRequest, rhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseActionRequest) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.optSelfCloseSysID != rhs.optSelfCloseSysID {return false}
    if lhs.actionFlag != rhs.actionFlag {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.optSelfCloseFlag != rhs.optSelfCloseFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OptionSelfCloseActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OptionSelfCloseActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "option_self_close_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.optionSelfCloseSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.optionSelfCloseSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionSelfCloseSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseActionResponse, rhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseActionResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.optionSelfCloseSysID != rhs.optionSelfCloseSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderInsertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderInsertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .standard(proto: "hedge_flag"),
    3: .same(proto: "direction"),
    4: .standard(proto: "offset_flag"),
    5: .standard(proto: "limit_price"),
    6: .standard(proto: "volume_total_original"),
    7: .standard(proto: "investor_id"),
    8: .standard(proto: "order_price_type"),
    9: .standard(proto: "time_condition"),
    10: .standard(proto: "volume_condition"),
    11: .standard(proto: "exchange_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.limitPrice) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.volumeTotalOriginal) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.orderPriceType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.timeCondition) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.volumeCondition) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 2)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 3)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 4)
    }
    if !self.limitPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.limitPrice, fieldNumber: 5)
    }
    if self.volumeTotalOriginal != 0 {
      try visitor.visitSingularInt32Field(value: self.volumeTotalOriginal, fieldNumber: 6)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 7)
    }
    if !self.orderPriceType.isEmpty {
      try visitor.visitSingularStringField(value: self.orderPriceType, fieldNumber: 8)
    }
    if !self.timeCondition.isEmpty {
      try visitor.visitSingularStringField(value: self.timeCondition, fieldNumber: 9)
    }
    if !self.volumeCondition.isEmpty {
      try visitor.visitSingularStringField(value: self.volumeCondition, fieldNumber: 10)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderInsertRequest, rhs: Com_Gtjaqh_Trader_Task_OrderInsertRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.limitPrice != rhs.limitPrice {return false}
    if lhs.volumeTotalOriginal != rhs.volumeTotalOriginal {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.orderPriceType != rhs.orderPriceType {return false}
    if lhs.timeCondition != rhs.timeCondition {return false}
    if lhs.volumeCondition != rhs.volumeCondition {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderInsertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderInsertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "order_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.orderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderInsertResponse, rhs: Com_Gtjaqh_Trader_Task_OrderInsertResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.orderSysID != rhs.orderSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_sys_id"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "exchange_id"),
    4: .standard(proto: "investor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderSysID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSysID, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 3)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderActionRequest, rhs: Com_Gtjaqh_Trader_Task_OrderActionRequest) -> Bool {
    if lhs.orderSysID != rhs.orderSysID {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "order_sys_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderSysID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.orderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSysID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderActionResponse, rhs: Com_Gtjaqh_Trader_Task_OrderActionResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.orderSysID != rhs.orderSysID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_TradeConfirmationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeConfirmationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "trade_field"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tradeField) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.errorID.isEmpty {
      try visitor.visitSingularStringField(value: self.errorID, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try { if let v = self._tradeField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_TradeConfirmationResponse, rhs: Com_Gtjaqh_Trader_Task_TradeConfirmationResponse) -> Bool {
    if lhs.errorID != rhs.errorID {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs._tradeField != rhs._tradeField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderConfirmationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderConfirmationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_id"),
    2: .standard(proto: "error_msg"),
    3: .standard(proto: "order_field"),
    4: .standard(proto: "order_type"),
  ]

  fileprivate class _StorageClass {
    var _errorID: String = String()
    var _errorMsg: String = String()
    var _orderField: Com_Gtjaqh_Trader_Task_OrderField? = nil
    var _orderType: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _errorID = source._errorID
      _errorMsg = source._errorMsg
      _orderField = source._orderField
      _orderType = source._orderType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._errorID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._errorMsg) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._orderField) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._orderType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._errorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorID, fieldNumber: 1)
      }
      if !_storage._errorMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMsg, fieldNumber: 2)
      }
      try { if let v = _storage._orderField {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._orderType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderType, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderConfirmationResponse, rhs: Com_Gtjaqh_Trader_Task_OrderConfirmationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._errorID != rhs_storage._errorID {return false}
        if _storage._errorMsg != rhs_storage._errorMsg {return false}
        if _storage._orderField != rhs_storage._orderField {return false}
        if _storage._orderType != rhs_storage._orderType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
