// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TraderTaskDataStruct.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Author      : meiyu024717@gtjas.com
// Version     : TTD_V1.11
// Update      : 2024/03/13
// Discription : 期权自对冲新增委托状态名称 是否可撤

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///交易编码
struct Com_Gtjaqh_Trader_Task_TradingCode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易所代码
  var exchangeID: String = String()

  ///客户代码
  var clientID: String = String()

  ///是否活跃 (1=活跃;0=非活跃)
  var isActive: String = String()

  ///交易编码类型 (1=投机;2=套利;3=套保;5=做市商)
  var clientIDType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///期货持仓明细
struct Com_Gtjaqh_Trader_Task_PositionField: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///合约代码
  var instrumentID: String {
    get {return _storage._instrumentID}
    set {_uniqueStorage()._instrumentID = newValue}
  }

  ///开仓成本    开仓均价==(开仓成本/(最小合约乘数*当前持仓量))
  var openCost: String {
    get {return _storage._openCost}
    set {_uniqueStorage()._openCost = newValue}
  }

  ///持仓成本    持仓均价==(持仓成本/(最小合约乘数*当前持仓量))
  var positionCost: String {
    get {return _storage._positionCost}
    set {_uniqueStorage()._positionCost = newValue}
  }

  ///可用数量 (总仓-平仓冻结-行权冻结)
  var availablePosition: Int32 {
    get {return _storage._availablePosition}
    set {_uniqueStorage()._availablePosition = newValue}
  }

  ///今日持仓 - 当前持仓数量
  var position: Int32 {
    get {return _storage._position}
    set {_uniqueStorage()._position = newValue}
  }

  ///投资者代码
  var investorID: String {
    get {return _storage._investorID}
    set {_uniqueStorage()._investorID = newValue}
  }

  ///持仓多空方向 (1=净;2=多头;3=空头)
  var posiDirection: String {
    get {return _storage._posiDirection}
    set {_uniqueStorage()._posiDirection = newValue}
  }

  ///交易所代码 - 交易类别
  var exchangeID: String {
    get {return _storage._exchangeID}
    set {_uniqueStorage()._exchangeID = newValue}
  }

  ///TAS 持仓手数
  var tasPosition: Int32 {
    get {return _storage._tasPosition}
    set {_uniqueStorage()._tasPosition = newValue}
  }

  ///TAS 持仓成本  TAS持仓均价==(tas持仓成本/tas持仓手数)
  var tasPositionCost: String {
    get {return _storage._tasPositionCost}
    set {_uniqueStorage()._tasPositionCost = newValue}
  }

  ///当日开仓可用数量 (TodayPosition>Position?Position:TodayPosition)
  var todayAvailablePosition: Int32 {
    get {return _storage._todayAvailablePosition}
    set {_uniqueStorage()._todayAvailablePosition = newValue}
  }

  ///投机套保标记 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String {
    get {return _storage._hedgeFlag}
    set {_uniqueStorage()._hedgeFlag = newValue}
  }

  ///占用的保证金
  var userMargin: String {
    get {return _storage._userMargin}
    set {_uniqueStorage()._userMargin = newValue}
  }

  ///本次结算价 - 最新价
  var settlementPrice: String {
    get {return _storage._settlementPrice}
    set {_uniqueStorage()._settlementPrice = newValue}
  }

  ///逐笔对冲平仓盈亏
  var closeProfitByTrade: String {
    get {return _storage._closeProfitByTrade}
    set {_uniqueStorage()._closeProfitByTrade = newValue}
  }

  ///逐日盯市平仓盈亏
  var closeProfitByDate: String {
    get {return _storage._closeProfitByDate}
    set {_uniqueStorage()._closeProfitByDate = newValue}
  }

  ///产品类型 (1=期货;2=期货期权;3=组合;4=即期;5=期转现;6=现货期权;7=TAS合约;I=金属指数)
  var productClass: String {
    get {return _storage._productClass}
    set {_uniqueStorage()._productClass = newValue}
  }

  ///持仓类型 (1=净持仓;2=综合持仓)
  var positionType: String {
    get {return _storage._positionType}
    set {_uniqueStorage()._positionType = newValue}
  }

  ///到期日 yyyymmdd
  var expireDate: String {
    get {return _storage._expireDate}
    set {_uniqueStorage()._expireDate = newValue}
  }

  ///期权类型 (1=看涨;2=看跌)
  var optionsType: String {
    get {return _storage._optionsType}
    set {_uniqueStorage()._optionsType = newValue}
  }

  ///基础商品代码 - 期权标的合约
  var underlyingInstrID: String {
    get {return _storage._underlyingInstrID}
    set {_uniqueStorage()._underlyingInstrID = newValue}
  }

  ///执行价 - 期权行权价格
  var strikePrice: String {
    get {return _storage._strikePrice}
    set {_uniqueStorage()._strikePrice = newValue}
  }

  ///开仓均价 - (开仓成本/(最小合约乘数*当前持仓量))
  var openCostAvg: String {
    get {return _storage._openCostAvg}
    set {_uniqueStorage()._openCostAvg = newValue}
  }

  ///持仓均价 - (持仓成本/(最小合约乘数*当前持仓量))
  var positionCostAvg: String {
    get {return _storage._positionCostAvg}
    set {_uniqueStorage()._positionCostAvg = newValue}
  }

  ///买卖方向 - 根据持仓多空方向转换 (净->NULL;2(多头)->0(买);3(空头)->1(卖))
  var direction: String {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  ///持仓盈亏
  var positionProfit: String {
    get {return _storage._positionProfit}
    set {_uniqueStorage()._positionProfit = newValue}
  }

  ///平仓盈亏 - 逐日
  var closeProfit: String {
    get {return _storage._closeProfit}
    set {_uniqueStorage()._closeProfit = newValue}
  }

  ///上次结算价 - 昨结
  var preSettlementPrice: String {
    get {return _storage._preSettlementPrice}
    set {_uniqueStorage()._preSettlementPrice = newValue}
  }

  ///今日持仓 - 持有今仓总数量
  var todayPosition: Int32 {
    get {return _storage._todayPosition}
    set {_uniqueStorage()._todayPosition = newValue}
  }

  ///今仓开仓成本 - 持有今仓总成本
  var todayOpenPositionCost: String {
    get {return _storage._todayOpenPositionCost}
    set {_uniqueStorage()._todayOpenPositionCost = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///委托结果
struct Com_Gtjaqh_Trader_Task_OrderField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///报单编号
  var orderSysID: String = String()

  ///交易所合约代码
  var exchangeInstID: String = String()

  ///投资者代码
  var investorID: String = String()

  ///交易所代码 - 委托类别
  var exchangeID: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///委托价格
  var limitPrice: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///委托状态 (0=全部成交;1=部分成交还在队列中;2=部分成交不在队列中;3=未成交还在队列中;4=未成交不在队列中;5=撤单;a=未知;b=尚未触发;c=已触发)
  var orderStatus: String = String()

  ///委托数量
  var volumeTotalOriginal: Int32 = 0

  ///委托时间
  var insertTime: String = String()

  ///成交数量
  var volumeTraded: Int32 = 0

  ///委托状态名称
  var orderStatusName: String = String()

  ///开平状态名称
  var offsetDirectionName: String = String()

  ///是否可撤 (false=不可撤单;true=可撤单)
  var isActionable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///成交结果
struct Com_Gtjaqh_Trader_Task_TradeField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///报单编号
  var orderSysID: String = String()

  ///交易所合约代码
  var exchangeInstID: String = String()

  ///投资者代码
  var investorID: String = String()

  ///交易所代码 - 委托类别
  var exchangeID: String = String()

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String = String()

  ///价格
  var price: String = String()

  ///买卖方向 (0=买;1=卖)
  var direction: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///数量
  var volume: Int32 = 0

  ///成交编号
  var tradeID: String = String()

  ///成交时间
  var tradeTime: String = String()

  ///开平状态名称
  var offsetDirectionName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///银期转账交易流水
struct Com_Gtjaqh_Trader_Task_TransferSerialField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///平台流水号
  var plateSerial: String = String()

  ///期货公司流水号
  var futureSerial: String = String()

  ///银行编码
  var bankID: String = String()

  ///银行账号
  var bankAccount: String = String()

  ///投资者代码
  var investorID: String = String()

  ///交易金额
  var tradeAmount: String = String()

  ///交易发起日期 yyyymmdd
  var tradeDate: String = String()

  ///成交时间
  var tradeTime: String = String()

  ///交易日期
  var tradingDay: String = String()

  ///有效标志 (0=未确认;1=有效;2=冲正)
  var availabilityFlag: String = String()

  ///流水返回码
  var rtnCode: String = String()

  ///流水返回信息
  var rtnMsg: String = String()

  ///银行名称
  var bankName: String = String()

  ///业务类别 (1=入金;2=出金;3=入金冲正;4=出金冲正;a=未知)
  var transferDirection: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///期权行权委托结果
struct Com_Gtjaqh_Trader_Task_ExecOrderField: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易所合约代码
  var exchangeInstID: String {
    get {return _storage._exchangeInstID}
    set {_uniqueStorage()._exchangeInstID = newValue}
  }

  ///投资者代码
  var investorID: String {
    get {return _storage._investorID}
    set {_uniqueStorage()._investorID = newValue}
  }

  ///资金账号
  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  ///交易所代码
  var exchangeID: String {
    get {return _storage._exchangeID}
    set {_uniqueStorage()._exchangeID = newValue}
  }

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String {
    get {return _storage._hedgeFlag}
    set {_uniqueStorage()._hedgeFlag = newValue}
  }

  ///期权行权报单编号
  var execOrderSysID: String {
    get {return _storage._execOrderSysID}
    set {_uniqueStorage()._execOrderSysID = newValue}
  }

  ///保留头寸申请的持仓方向 (1=净;2=多头;3=空头)
  var posiDirection: String {
    get {return _storage._posiDirection}
    set {_uniqueStorage()._posiDirection = newValue}
  }

  ///期权行权后生成的头寸是否自动平仓 - 自动平仓标志 (0=自动;1=非自动)
  var closeFlag: String {
    get {return _storage._closeFlag}
    set {_uniqueStorage()._closeFlag = newValue}
  }

  ///数量
  var volume: Int32 {
    get {return _storage._volume}
    set {_uniqueStorage()._volume = newValue}
  }

  ///执行类型 (1=执行;2=放弃)
  var actionType: String {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  ///插入时间
  var insertTime: String {
    get {return _storage._insertTime}
    set {_uniqueStorage()._insertTime = newValue}
  }

  ///会话编号
  var sessionID: Int32 {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  ///开平标志 (0=开仓;1=平仓;2=强平;3=平今;4=平昨;5=强减;6=本地强平)
  var offsetFlag: String {
    get {return _storage._offsetFlag}
    set {_uniqueStorage()._offsetFlag = newValue}
  }

  ///执行结果 (随柜台不同而有不同的返回值)
  var execResult: String {
    get {return _storage._execResult}
    set {_uniqueStorage()._execResult = newValue}
  }

  ///期权类型 (1=看涨;2=看跌)
  var optionsType: String {
    get {return _storage._optionsType}
    set {_uniqueStorage()._optionsType = newValue}
  }

  ///基础商品代码 - 期权标的合约
  var underlyingInstrID: String {
    get {return _storage._underlyingInstrID}
    set {_uniqueStorage()._underlyingInstrID = newValue}
  }

  ///执行结果名称 (已中文转译)
  var execResultName: String {
    get {return _storage._execResultName}
    set {_uniqueStorage()._execResultName = newValue}
  }

  ///是否可撤 (false=不可撤单;true=可撤单)
  var isActionable: Bool {
    get {return _storage._isActionable}
    set {_uniqueStorage()._isActionable = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///期权自对冲委托结果
struct Com_Gtjaqh_Trader_Task_OptionSelfCloseField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///交易所合约代码
  var exchangeInstID: String = String()

  ///投资者代码
  var investorID: String = String()

  ///资金账号
  var accountID: String = String()

  ///交易所代码
  var exchangeID: String = String()

  ///投机套保标志 (1=投机;2=套利;3=套保;5=做市商;6=第一腿投机第二腿套保,大商所专用;7=第一腿套保第二腿投机,大商所专用)
  var hedgeFlag: String = String()

  ///期权自对冲编号
  var optionSelfClosSysID: String = String()

  ///期权行权的头寸是否自对冲 (1=自对冲期权仓位;2=保留期权仓位;3=自对冲卖方履约后的期货仓位;4=保留卖方履约后的期货仓位)
  var optSelfCloseFlag: String = String()

  ///自对冲提交状态 (0=已经提交;1=撤单已经提交;2=修改已经提交;3=已经接受;4=报单已经被拒绝;5=撤单已经被拒绝;6=改单已经被拒绝)
  var orderSubmitStatus: String = String()

  ///数量
  var volume: Int32 = 0

  ///执行类型 (1=执行;2=放弃)
  var actionType: String = String()

  ///报单日期
  var insertDate: String = String()

  ///插入时间
  var insertTime: String = String()

  ///撤销时间
  var cancelTime: String = String()

  ///执行结果 (n=没有执行;c=已经取消;0=执行成功;1=期权持仓不够;2=资金不够;3=会员不存在;4=客户不存在;6=合约不存在;7=没有执行权限;8=不合理的数量;9=没有足够的历史成交;a=未知)
  var execResult: String = String()

  ///委托状态名称
  var orderSubmitStatusName: String = String()

  ///是否可撤 (false=不可撤单;true=可撤单)
  var isActionable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///银期签约关系明细
struct Com_Gtjaqh_Trader_Task_AccountregisterField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///投资者账号
  var accountID: String = String()

  ///银行代码
  var bankID: String = String()

  ///银行名称
  var bankName: String = String()

  ///银行分支机构代码
  var bankBranchID: String = String()

  ///银行帐号
  var bankAccount: String = String()

  ///币种代码 (CNY=人民币;USD=美元;HKD=港币)
  var currencyID: String = String()

  ///币种代码名称
  var currencyIDName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 银行信息
struct Com_Gtjaqh_Trader_Task_ContractBankField: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 银行代码
  var brokerID: String = String()

  /// 银行分中心代码
  var bankBrchID: String = String()

  /// 银行名称
  var bankName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.gtjaqh.trader.task"

extension Com_Gtjaqh_Trader_Task_TradingCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingCode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "client_id"),
    3: .standard(proto: "is_active"),
    4: .standard(proto: "client_id_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.isActive) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientIDType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.isActive.isEmpty {
      try visitor.visitSingularStringField(value: self.isActive, fieldNumber: 3)
    }
    if !self.clientIDType.isEmpty {
      try visitor.visitSingularStringField(value: self.clientIDType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_TradingCode, rhs: Com_Gtjaqh_Trader_Task_TradingCode) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs.clientIDType != rhs.clientIDType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_PositionField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .standard(proto: "open_cost"),
    3: .standard(proto: "position_cost"),
    4: .standard(proto: "available_position"),
    5: .same(proto: "position"),
    6: .standard(proto: "investor_id"),
    7: .standard(proto: "posi_direction"),
    8: .standard(proto: "exchange_id"),
    9: .standard(proto: "tas_position"),
    10: .standard(proto: "tas_position_cost"),
    11: .standard(proto: "today_available_position"),
    12: .standard(proto: "hedge_flag"),
    13: .standard(proto: "user_margin"),
    14: .standard(proto: "settlement_price"),
    15: .standard(proto: "close_profit_by_trade"),
    16: .standard(proto: "close_profit_by_date"),
    17: .standard(proto: "product_class"),
    18: .standard(proto: "position_type"),
    19: .standard(proto: "expire_date"),
    20: .standard(proto: "options_type"),
    21: .standard(proto: "underlying_instr_id"),
    22: .standard(proto: "strike_price"),
    23: .standard(proto: "open_cost_avg"),
    24: .standard(proto: "position_cost_avg"),
    25: .same(proto: "direction"),
    26: .standard(proto: "position_profit"),
    27: .standard(proto: "close_profit"),
    28: .standard(proto: "pre_settlement_price"),
    29: .standard(proto: "today_position"),
    30: .standard(proto: "today_open_position_cost"),
  ]

  fileprivate class _StorageClass {
    var _instrumentID: String = String()
    var _openCost: String = String()
    var _positionCost: String = String()
    var _availablePosition: Int32 = 0
    var _position: Int32 = 0
    var _investorID: String = String()
    var _posiDirection: String = String()
    var _exchangeID: String = String()
    var _tasPosition: Int32 = 0
    var _tasPositionCost: String = String()
    var _todayAvailablePosition: Int32 = 0
    var _hedgeFlag: String = String()
    var _userMargin: String = String()
    var _settlementPrice: String = String()
    var _closeProfitByTrade: String = String()
    var _closeProfitByDate: String = String()
    var _productClass: String = String()
    var _positionType: String = String()
    var _expireDate: String = String()
    var _optionsType: String = String()
    var _underlyingInstrID: String = String()
    var _strikePrice: String = String()
    var _openCostAvg: String = String()
    var _positionCostAvg: String = String()
    var _direction: String = String()
    var _positionProfit: String = String()
    var _closeProfit: String = String()
    var _preSettlementPrice: String = String()
    var _todayPosition: Int32 = 0
    var _todayOpenPositionCost: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _instrumentID = source._instrumentID
      _openCost = source._openCost
      _positionCost = source._positionCost
      _availablePosition = source._availablePosition
      _position = source._position
      _investorID = source._investorID
      _posiDirection = source._posiDirection
      _exchangeID = source._exchangeID
      _tasPosition = source._tasPosition
      _tasPositionCost = source._tasPositionCost
      _todayAvailablePosition = source._todayAvailablePosition
      _hedgeFlag = source._hedgeFlag
      _userMargin = source._userMargin
      _settlementPrice = source._settlementPrice
      _closeProfitByTrade = source._closeProfitByTrade
      _closeProfitByDate = source._closeProfitByDate
      _productClass = source._productClass
      _positionType = source._positionType
      _expireDate = source._expireDate
      _optionsType = source._optionsType
      _underlyingInstrID = source._underlyingInstrID
      _strikePrice = source._strikePrice
      _openCostAvg = source._openCostAvg
      _positionCostAvg = source._positionCostAvg
      _direction = source._direction
      _positionProfit = source._positionProfit
      _closeProfit = source._closeProfit
      _preSettlementPrice = source._preSettlementPrice
      _todayPosition = source._todayPosition
      _todayOpenPositionCost = source._todayOpenPositionCost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._instrumentID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._openCost) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._positionCost) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._availablePosition) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._position) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._investorID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._posiDirection) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._exchangeID) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._tasPosition) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._tasPositionCost) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._todayAvailablePosition) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._hedgeFlag) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._userMargin) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._settlementPrice) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._closeProfitByTrade) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._closeProfitByDate) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._productClass) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._positionType) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._expireDate) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._optionsType) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._underlyingInstrID) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._strikePrice) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._openCostAvg) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._positionCostAvg) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._direction) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._positionProfit) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._closeProfit) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._preSettlementPrice) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._todayPosition) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._todayOpenPositionCost) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._instrumentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentID, fieldNumber: 1)
      }
      if !_storage._openCost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._openCost, fieldNumber: 2)
      }
      if !_storage._positionCost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionCost, fieldNumber: 3)
      }
      if _storage._availablePosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._availablePosition, fieldNumber: 4)
      }
      if _storage._position != 0 {
        try visitor.visitSingularInt32Field(value: _storage._position, fieldNumber: 5)
      }
      if !_storage._investorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._investorID, fieldNumber: 6)
      }
      if !_storage._posiDirection.isEmpty {
        try visitor.visitSingularStringField(value: _storage._posiDirection, fieldNumber: 7)
      }
      if !_storage._exchangeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchangeID, fieldNumber: 8)
      }
      if _storage._tasPosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tasPosition, fieldNumber: 9)
      }
      if !_storage._tasPositionCost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tasPositionCost, fieldNumber: 10)
      }
      if _storage._todayAvailablePosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._todayAvailablePosition, fieldNumber: 11)
      }
      if !_storage._hedgeFlag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hedgeFlag, fieldNumber: 12)
      }
      if !_storage._userMargin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userMargin, fieldNumber: 13)
      }
      if !_storage._settlementPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlementPrice, fieldNumber: 14)
      }
      if !_storage._closeProfitByTrade.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeProfitByTrade, fieldNumber: 15)
      }
      if !_storage._closeProfitByDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeProfitByDate, fieldNumber: 16)
      }
      if !_storage._productClass.isEmpty {
        try visitor.visitSingularStringField(value: _storage._productClass, fieldNumber: 17)
      }
      if !_storage._positionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionType, fieldNumber: 18)
      }
      if !_storage._expireDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._expireDate, fieldNumber: 19)
      }
      if !_storage._optionsType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._optionsType, fieldNumber: 20)
      }
      if !_storage._underlyingInstrID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._underlyingInstrID, fieldNumber: 21)
      }
      if !_storage._strikePrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._strikePrice, fieldNumber: 22)
      }
      if !_storage._openCostAvg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._openCostAvg, fieldNumber: 23)
      }
      if !_storage._positionCostAvg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionCostAvg, fieldNumber: 24)
      }
      if !_storage._direction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._direction, fieldNumber: 25)
      }
      if !_storage._positionProfit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._positionProfit, fieldNumber: 26)
      }
      if !_storage._closeProfit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeProfit, fieldNumber: 27)
      }
      if !_storage._preSettlementPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preSettlementPrice, fieldNumber: 28)
      }
      if _storage._todayPosition != 0 {
        try visitor.visitSingularInt32Field(value: _storage._todayPosition, fieldNumber: 29)
      }
      if !_storage._todayOpenPositionCost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._todayOpenPositionCost, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_PositionField, rhs: Com_Gtjaqh_Trader_Task_PositionField) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instrumentID != rhs_storage._instrumentID {return false}
        if _storage._openCost != rhs_storage._openCost {return false}
        if _storage._positionCost != rhs_storage._positionCost {return false}
        if _storage._availablePosition != rhs_storage._availablePosition {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._investorID != rhs_storage._investorID {return false}
        if _storage._posiDirection != rhs_storage._posiDirection {return false}
        if _storage._exchangeID != rhs_storage._exchangeID {return false}
        if _storage._tasPosition != rhs_storage._tasPosition {return false}
        if _storage._tasPositionCost != rhs_storage._tasPositionCost {return false}
        if _storage._todayAvailablePosition != rhs_storage._todayAvailablePosition {return false}
        if _storage._hedgeFlag != rhs_storage._hedgeFlag {return false}
        if _storage._userMargin != rhs_storage._userMargin {return false}
        if _storage._settlementPrice != rhs_storage._settlementPrice {return false}
        if _storage._closeProfitByTrade != rhs_storage._closeProfitByTrade {return false}
        if _storage._closeProfitByDate != rhs_storage._closeProfitByDate {return false}
        if _storage._productClass != rhs_storage._productClass {return false}
        if _storage._positionType != rhs_storage._positionType {return false}
        if _storage._expireDate != rhs_storage._expireDate {return false}
        if _storage._optionsType != rhs_storage._optionsType {return false}
        if _storage._underlyingInstrID != rhs_storage._underlyingInstrID {return false}
        if _storage._strikePrice != rhs_storage._strikePrice {return false}
        if _storage._openCostAvg != rhs_storage._openCostAvg {return false}
        if _storage._positionCostAvg != rhs_storage._positionCostAvg {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._positionProfit != rhs_storage._positionProfit {return false}
        if _storage._closeProfit != rhs_storage._closeProfit {return false}
        if _storage._preSettlementPrice != rhs_storage._preSettlementPrice {return false}
        if _storage._todayPosition != rhs_storage._todayPosition {return false}
        if _storage._todayOpenPositionCost != rhs_storage._todayOpenPositionCost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OrderField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_sys_id"),
    2: .standard(proto: "exchange_inst_id"),
    3: .standard(proto: "investor_id"),
    4: .standard(proto: "exchange_id"),
    5: .standard(proto: "offset_flag"),
    6: .standard(proto: "limit_price"),
    7: .same(proto: "direction"),
    8: .standard(proto: "hedge_flag"),
    9: .standard(proto: "order_status"),
    10: .standard(proto: "volume_total_original"),
    11: .standard(proto: "insert_time"),
    12: .standard(proto: "volume_traded"),
    13: .standard(proto: "order_status_name"),
    14: .standard(proto: "offset_direction_name"),
    15: .standard(proto: "is_actionable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderSysID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exchangeInstID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.limitPrice) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.orderStatus) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.volumeTotalOriginal) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.insertTime) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.volumeTraded) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.orderStatusName) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.offsetDirectionName) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.isActionable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSysID, fieldNumber: 1)
    }
    if !self.exchangeInstID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeInstID, fieldNumber: 2)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 3)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 4)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 5)
    }
    if !self.limitPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.limitPrice, fieldNumber: 6)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 7)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 8)
    }
    if !self.orderStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.orderStatus, fieldNumber: 9)
    }
    if self.volumeTotalOriginal != 0 {
      try visitor.visitSingularInt32Field(value: self.volumeTotalOriginal, fieldNumber: 10)
    }
    if !self.insertTime.isEmpty {
      try visitor.visitSingularStringField(value: self.insertTime, fieldNumber: 11)
    }
    if self.volumeTraded != 0 {
      try visitor.visitSingularInt32Field(value: self.volumeTraded, fieldNumber: 12)
    }
    if !self.orderStatusName.isEmpty {
      try visitor.visitSingularStringField(value: self.orderStatusName, fieldNumber: 13)
    }
    if !self.offsetDirectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetDirectionName, fieldNumber: 14)
    }
    if self.isActionable != false {
      try visitor.visitSingularBoolField(value: self.isActionable, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OrderField, rhs: Com_Gtjaqh_Trader_Task_OrderField) -> Bool {
    if lhs.orderSysID != rhs.orderSysID {return false}
    if lhs.exchangeInstID != rhs.exchangeInstID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.limitPrice != rhs.limitPrice {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.orderStatus != rhs.orderStatus {return false}
    if lhs.volumeTotalOriginal != rhs.volumeTotalOriginal {return false}
    if lhs.insertTime != rhs.insertTime {return false}
    if lhs.volumeTraded != rhs.volumeTraded {return false}
    if lhs.orderStatusName != rhs.orderStatusName {return false}
    if lhs.offsetDirectionName != rhs.offsetDirectionName {return false}
    if lhs.isActionable != rhs.isActionable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_TradeField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_sys_id"),
    2: .standard(proto: "exchange_inst_id"),
    3: .standard(proto: "investor_id"),
    4: .standard(proto: "exchange_id"),
    5: .standard(proto: "offset_flag"),
    6: .same(proto: "price"),
    7: .same(proto: "direction"),
    8: .standard(proto: "hedge_flag"),
    9: .same(proto: "volume"),
    10: .standard(proto: "trade_id"),
    11: .standard(proto: "trade_time"),
    12: .standard(proto: "offset_direction_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderSysID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exchangeInstID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.offsetFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.direction) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.volume) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.tradeID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.tradeTime) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.offsetDirectionName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSysID, fieldNumber: 1)
    }
    if !self.exchangeInstID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeInstID, fieldNumber: 2)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 3)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 4)
    }
    if !self.offsetFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetFlag, fieldNumber: 5)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 6)
    }
    if !self.direction.isEmpty {
      try visitor.visitSingularStringField(value: self.direction, fieldNumber: 7)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 8)
    }
    if self.volume != 0 {
      try visitor.visitSingularInt32Field(value: self.volume, fieldNumber: 9)
    }
    if !self.tradeID.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeID, fieldNumber: 10)
    }
    if !self.tradeTime.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeTime, fieldNumber: 11)
    }
    if !self.offsetDirectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.offsetDirectionName, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_TradeField, rhs: Com_Gtjaqh_Trader_Task_TradeField) -> Bool {
    if lhs.orderSysID != rhs.orderSysID {return false}
    if lhs.exchangeInstID != rhs.exchangeInstID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.offsetFlag != rhs.offsetFlag {return false}
    if lhs.price != rhs.price {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.tradeID != rhs.tradeID {return false}
    if lhs.tradeTime != rhs.tradeTime {return false}
    if lhs.offsetDirectionName != rhs.offsetDirectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_TransferSerialField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferSerialField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "plate_serial"),
    2: .standard(proto: "future_serial"),
    3: .standard(proto: "bank_id"),
    4: .standard(proto: "bank_account"),
    5: .standard(proto: "investor_id"),
    6: .standard(proto: "trade_amount"),
    7: .standard(proto: "trade_date"),
    8: .standard(proto: "trade_time"),
    9: .standard(proto: "trading_day"),
    10: .standard(proto: "availability_flag"),
    11: .standard(proto: "rtn_code"),
    12: .standard(proto: "rtn_msg"),
    13: .standard(proto: "bank_name"),
    14: .standard(proto: "transfer_direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.plateSerial) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.futureSerial) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bankAccount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.tradeAmount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.tradeDate) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.tradeTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.tradingDay) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.availabilityFlag) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.rtnCode) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.rtnMsg) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.bankName) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.transferDirection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plateSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.plateSerial, fieldNumber: 1)
    }
    if !self.futureSerial.isEmpty {
      try visitor.visitSingularStringField(value: self.futureSerial, fieldNumber: 2)
    }
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 3)
    }
    if !self.bankAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankAccount, fieldNumber: 4)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 5)
    }
    if !self.tradeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeAmount, fieldNumber: 6)
    }
    if !self.tradeDate.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeDate, fieldNumber: 7)
    }
    if !self.tradeTime.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeTime, fieldNumber: 8)
    }
    if !self.tradingDay.isEmpty {
      try visitor.visitSingularStringField(value: self.tradingDay, fieldNumber: 9)
    }
    if !self.availabilityFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.availabilityFlag, fieldNumber: 10)
    }
    if !self.rtnCode.isEmpty {
      try visitor.visitSingularStringField(value: self.rtnCode, fieldNumber: 11)
    }
    if !self.rtnMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.rtnMsg, fieldNumber: 12)
    }
    if !self.bankName.isEmpty {
      try visitor.visitSingularStringField(value: self.bankName, fieldNumber: 13)
    }
    if !self.transferDirection.isEmpty {
      try visitor.visitSingularStringField(value: self.transferDirection, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_TransferSerialField, rhs: Com_Gtjaqh_Trader_Task_TransferSerialField) -> Bool {
    if lhs.plateSerial != rhs.plateSerial {return false}
    if lhs.futureSerial != rhs.futureSerial {return false}
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankAccount != rhs.bankAccount {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.tradeAmount != rhs.tradeAmount {return false}
    if lhs.tradeDate != rhs.tradeDate {return false}
    if lhs.tradeTime != rhs.tradeTime {return false}
    if lhs.tradingDay != rhs.tradingDay {return false}
    if lhs.availabilityFlag != rhs.availabilityFlag {return false}
    if lhs.rtnCode != rhs.rtnCode {return false}
    if lhs.rtnMsg != rhs.rtnMsg {return false}
    if lhs.bankName != rhs.bankName {return false}
    if lhs.transferDirection != rhs.transferDirection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ExecOrderField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecOrderField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_inst_id"),
    2: .standard(proto: "investor_id"),
    3: .standard(proto: "account_id"),
    4: .standard(proto: "exchange_id"),
    5: .standard(proto: "hedge_flag"),
    6: .standard(proto: "exec_order_sys_id"),
    7: .standard(proto: "posi_direction"),
    8: .standard(proto: "close_flag"),
    9: .same(proto: "volume"),
    10: .standard(proto: "action_type"),
    11: .standard(proto: "insert_time"),
    12: .standard(proto: "session_id"),
    13: .standard(proto: "offset_flag"),
    14: .standard(proto: "exec_result"),
    15: .standard(proto: "options_type"),
    16: .standard(proto: "underlying_instr_id"),
    17: .standard(proto: "exec_result_name"),
    18: .standard(proto: "is_actionable"),
  ]

  fileprivate class _StorageClass {
    var _exchangeInstID: String = String()
    var _investorID: String = String()
    var _accountID: String = String()
    var _exchangeID: String = String()
    var _hedgeFlag: String = String()
    var _execOrderSysID: String = String()
    var _posiDirection: String = String()
    var _closeFlag: String = String()
    var _volume: Int32 = 0
    var _actionType: String = String()
    var _insertTime: String = String()
    var _sessionID: Int32 = 0
    var _offsetFlag: String = String()
    var _execResult: String = String()
    var _optionsType: String = String()
    var _underlyingInstrID: String = String()
    var _execResultName: String = String()
    var _isActionable: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _exchangeInstID = source._exchangeInstID
      _investorID = source._investorID
      _accountID = source._accountID
      _exchangeID = source._exchangeID
      _hedgeFlag = source._hedgeFlag
      _execOrderSysID = source._execOrderSysID
      _posiDirection = source._posiDirection
      _closeFlag = source._closeFlag
      _volume = source._volume
      _actionType = source._actionType
      _insertTime = source._insertTime
      _sessionID = source._sessionID
      _offsetFlag = source._offsetFlag
      _execResult = source._execResult
      _optionsType = source._optionsType
      _underlyingInstrID = source._underlyingInstrID
      _execResultName = source._execResultName
      _isActionable = source._isActionable
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._exchangeInstID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._investorID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._accountID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._exchangeID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._hedgeFlag) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._execOrderSysID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._posiDirection) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._closeFlag) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._volume) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._actionType) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._insertTime) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._sessionID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._offsetFlag) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._execResult) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._optionsType) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._underlyingInstrID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._execResultName) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isActionable) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._exchangeInstID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchangeInstID, fieldNumber: 1)
      }
      if !_storage._investorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._investorID, fieldNumber: 2)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 3)
      }
      if !_storage._exchangeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchangeID, fieldNumber: 4)
      }
      if !_storage._hedgeFlag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hedgeFlag, fieldNumber: 5)
      }
      if !_storage._execOrderSysID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._execOrderSysID, fieldNumber: 6)
      }
      if !_storage._posiDirection.isEmpty {
        try visitor.visitSingularStringField(value: _storage._posiDirection, fieldNumber: 7)
      }
      if !_storage._closeFlag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closeFlag, fieldNumber: 8)
      }
      if _storage._volume != 0 {
        try visitor.visitSingularInt32Field(value: _storage._volume, fieldNumber: 9)
      }
      if !_storage._actionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionType, fieldNumber: 10)
      }
      if !_storage._insertTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertTime, fieldNumber: 11)
      }
      if _storage._sessionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sessionID, fieldNumber: 12)
      }
      if !_storage._offsetFlag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._offsetFlag, fieldNumber: 13)
      }
      if !_storage._execResult.isEmpty {
        try visitor.visitSingularStringField(value: _storage._execResult, fieldNumber: 14)
      }
      if !_storage._optionsType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._optionsType, fieldNumber: 15)
      }
      if !_storage._underlyingInstrID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._underlyingInstrID, fieldNumber: 16)
      }
      if !_storage._execResultName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._execResultName, fieldNumber: 17)
      }
      if _storage._isActionable != false {
        try visitor.visitSingularBoolField(value: _storage._isActionable, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ExecOrderField, rhs: Com_Gtjaqh_Trader_Task_ExecOrderField) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._exchangeInstID != rhs_storage._exchangeInstID {return false}
        if _storage._investorID != rhs_storage._investorID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._exchangeID != rhs_storage._exchangeID {return false}
        if _storage._hedgeFlag != rhs_storage._hedgeFlag {return false}
        if _storage._execOrderSysID != rhs_storage._execOrderSysID {return false}
        if _storage._posiDirection != rhs_storage._posiDirection {return false}
        if _storage._closeFlag != rhs_storage._closeFlag {return false}
        if _storage._volume != rhs_storage._volume {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._insertTime != rhs_storage._insertTime {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._offsetFlag != rhs_storage._offsetFlag {return false}
        if _storage._execResult != rhs_storage._execResult {return false}
        if _storage._optionsType != rhs_storage._optionsType {return false}
        if _storage._underlyingInstrID != rhs_storage._underlyingInstrID {return false}
        if _storage._execResultName != rhs_storage._execResultName {return false}
        if _storage._isActionable != rhs_storage._isActionable {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_OptionSelfCloseField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OptionSelfCloseField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_inst_id"),
    2: .standard(proto: "investor_id"),
    3: .standard(proto: "account_id"),
    4: .standard(proto: "exchange_id"),
    5: .standard(proto: "hedge_flag"),
    6: .standard(proto: "option_self_clos_sys_id"),
    7: .standard(proto: "opt_self_close_flag"),
    8: .standard(proto: "order_submit_status"),
    9: .same(proto: "volume"),
    10: .standard(proto: "action_type"),
    11: .standard(proto: "insert_date"),
    12: .standard(proto: "insert_time"),
    13: .standard(proto: "cancel_time"),
    14: .standard(proto: "exec_result"),
    15: .standard(proto: "order_submit_status_name"),
    16: .standard(proto: "is_actionable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeInstID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.investorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.exchangeID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.hedgeFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.optionSelfClosSysID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.optSelfCloseFlag) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.orderSubmitStatus) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.volume) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.actionType) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.insertDate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.insertTime) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.cancelTime) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.execResult) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.orderSubmitStatusName) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.isActionable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeInstID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeInstID, fieldNumber: 1)
    }
    if !self.investorID.isEmpty {
      try visitor.visitSingularStringField(value: self.investorID, fieldNumber: 2)
    }
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 3)
    }
    if !self.exchangeID.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeID, fieldNumber: 4)
    }
    if !self.hedgeFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.hedgeFlag, fieldNumber: 5)
    }
    if !self.optionSelfClosSysID.isEmpty {
      try visitor.visitSingularStringField(value: self.optionSelfClosSysID, fieldNumber: 6)
    }
    if !self.optSelfCloseFlag.isEmpty {
      try visitor.visitSingularStringField(value: self.optSelfCloseFlag, fieldNumber: 7)
    }
    if !self.orderSubmitStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSubmitStatus, fieldNumber: 8)
    }
    if self.volume != 0 {
      try visitor.visitSingularInt32Field(value: self.volume, fieldNumber: 9)
    }
    if !self.actionType.isEmpty {
      try visitor.visitSingularStringField(value: self.actionType, fieldNumber: 10)
    }
    if !self.insertDate.isEmpty {
      try visitor.visitSingularStringField(value: self.insertDate, fieldNumber: 11)
    }
    if !self.insertTime.isEmpty {
      try visitor.visitSingularStringField(value: self.insertTime, fieldNumber: 12)
    }
    if !self.cancelTime.isEmpty {
      try visitor.visitSingularStringField(value: self.cancelTime, fieldNumber: 13)
    }
    if !self.execResult.isEmpty {
      try visitor.visitSingularStringField(value: self.execResult, fieldNumber: 14)
    }
    if !self.orderSubmitStatusName.isEmpty {
      try visitor.visitSingularStringField(value: self.orderSubmitStatusName, fieldNumber: 15)
    }
    if self.isActionable != false {
      try visitor.visitSingularBoolField(value: self.isActionable, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseField, rhs: Com_Gtjaqh_Trader_Task_OptionSelfCloseField) -> Bool {
    if lhs.exchangeInstID != rhs.exchangeInstID {return false}
    if lhs.investorID != rhs.investorID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.hedgeFlag != rhs.hedgeFlag {return false}
    if lhs.optionSelfClosSysID != rhs.optionSelfClosSysID {return false}
    if lhs.optSelfCloseFlag != rhs.optSelfCloseFlag {return false}
    if lhs.orderSubmitStatus != rhs.orderSubmitStatus {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.actionType != rhs.actionType {return false}
    if lhs.insertDate != rhs.insertDate {return false}
    if lhs.insertTime != rhs.insertTime {return false}
    if lhs.cancelTime != rhs.cancelTime {return false}
    if lhs.execResult != rhs.execResult {return false}
    if lhs.orderSubmitStatusName != rhs.orderSubmitStatusName {return false}
    if lhs.isActionable != rhs.isActionable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_AccountregisterField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountregisterField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "bank_id"),
    3: .standard(proto: "bank_name"),
    4: .standard(proto: "bank_branch_id"),
    5: .standard(proto: "bank_account"),
    6: .standard(proto: "currency_id"),
    7: .standard(proto: "currency_id_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bankBranchID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bankAccount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.currencyID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currencyIDName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.bankID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankID, fieldNumber: 2)
    }
    if !self.bankName.isEmpty {
      try visitor.visitSingularStringField(value: self.bankName, fieldNumber: 3)
    }
    if !self.bankBranchID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankBranchID, fieldNumber: 4)
    }
    if !self.bankAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.bankAccount, fieldNumber: 5)
    }
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 6)
    }
    if !self.currencyIDName.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyIDName, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_AccountregisterField, rhs: Com_Gtjaqh_Trader_Task_AccountregisterField) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.bankID != rhs.bankID {return false}
    if lhs.bankName != rhs.bankName {return false}
    if lhs.bankBranchID != rhs.bankBranchID {return false}
    if lhs.bankAccount != rhs.bankAccount {return false}
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.currencyIDName != rhs.currencyIDName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Gtjaqh_Trader_Task_ContractBankField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractBankField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broker_id"),
    2: .standard(proto: "bank_brch_id"),
    3: .standard(proto: "bank_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.brokerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bankBrchID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bankName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brokerID.isEmpty {
      try visitor.visitSingularStringField(value: self.brokerID, fieldNumber: 1)
    }
    if !self.bankBrchID.isEmpty {
      try visitor.visitSingularStringField(value: self.bankBrchID, fieldNumber: 2)
    }
    if !self.bankName.isEmpty {
      try visitor.visitSingularStringField(value: self.bankName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Com_Gtjaqh_Trader_Task_ContractBankField, rhs: Com_Gtjaqh_Trader_Task_ContractBankField) -> Bool {
    if lhs.brokerID != rhs.brokerID {return false}
    if lhs.bankBrchID != rhs.bankBrchID {return false}
    if lhs.bankName != rhs.bankName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
